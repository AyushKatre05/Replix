2025-05-30 19:09:12,146 - INFO - PROMPT: 
For the project `LinkedIn`:

Codebase Context:
--- File Index 0: README.md ---
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.js`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.


--- File Index 1: tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundImage: {
        "gradient-radial": "radial-gradient(var(--tw-gradient-stops))",
        "gradient-conic":
          "conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))",
      },
    },
  },
  plugins: [],
};


--- File Index 2: src\middleware.js ---
import { NextResponse } from 'next/server'
 
// This function can be marked `async` if using `await` inside
export function middleware(request) {
    const path = request.nextUrl.pathname

    const isPublicPath = path === '/login' || path === '/register'

    const token = request.cookies.get('token')?.value || ''

    if(isPublicPath && token){
        return NextResponse.redirect(new URL('/',request.nextUrl))
    }

    if(!isPublicPath && !token){
        return NextResponse.redirect(new URL('/login',request.nextUrl))
    }

}
 


// See "Matching Paths" below to learn more
export const config = {
  matcher: [    
    '/login',
    '/register',
    '/'
  ],
}

--- File Index 3: src\app\layout.js ---
import { Inter } from "next/font/google";
import "./globals.css";
import  { Toaster } from 'react-hot-toast';

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "LinkedIn",
  description: "Created by Ayush Katre",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}><Toaster />
        {children}
      </body>
    </html>
  );
}


--- File Index 4: src\app\(auth)\layout.js ---
import Image from 'next/image'
export default function AuthLayout({ children }) {
    return (
      <main>
        <header className="w-full sticky top-0 h-16 shadow z-40 bg-white">
          <div className="container mx-auto flex justify-center items-center h-full">
             <Image 
               src={'/logo.png'}
               width={200}
               height={90}
               alt='logo'
             />
          </div>
        </header>
        { children}
      </main>
    );
  }
  

--- File Index 5: src\app\(auth)\login\page.js ---
'use client'

import React, {  useState } from 'react'
import Link from 'next/link'
import axios from 'axios'
import toast from 'react-hot-toast';
import { useRouter } from 'next/navigation'

const Login = () => {
  const [data,setData] = useState({
    email : "",
    password : "",
  })
  const [loading,setLoading] = useState(false)
  const router = useRouter()

  const handleOnChange =  (e) =>{
    const {name , value } = e.target

    setData((preve)=>{
      return{
          ...preve,
           [name] : value
      }
    })
  }

  const handleSubmit = async(e) =>{
    e.preventDefault()

    const response = await axios.post('/api/login',data)
    toast(response.data.message)


    if(response.data.success){
      setData({
        email : "",
        password : "",
      })
      router.push("/")
    }
    
  }


  return (
    <section className='container w-full mx-auto p-1 mt-5'>
    <div className='w-full max-w-md bg-white shadow border p-4 mx-auto'>
        <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
          
          <div className='flex flex-col gap-1'>
                <label htmlFor='email'>Email:</label>
                <input
                  type='email'
                  name="email"
                  id='email'
                  value={data.email}
                  placeholder='enter email'
                  onChange={handleOnChange}
                  disabled={loading}
                  className='bg-slate-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
                />
          </div>


          <div className='flex flex-col gap-1'>
                <label htmlFor='password'>Password:</label>
                <input
                  type='password'
                  name="password"
                  id='password'
                  value={data.password}
                  placeholder='enter password'
                  onChange={handleOnChange}
                  disabled={loading}
                  className='bg-slate-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
                />
          </div>

          <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
        </form>

        <div className='my-5'>
          <p>Create new account ? <Link href={'/register'} className='text-blue-700 hover:text-blue-800 hover:underline'>Register</Link></p>
        </div>
    </div>
</section>
  )
}

export default Login

--- File Index 6: src\app\(auth)\register\page.js ---
'use client'

import React, { useRef, useState } from 'react'
import Image from 'next/image'
import Link from 'next/link'
import axios from 'axios'
import toast from 'react-hot-toast';
import { useRouter } from 'next/navigation'

const Register = () => {
  const [data, setData] = useState({
    firstName: "",
    lastName: "",
    location: "",
    occupation: "",
    email: "",
    password: "",
    profile_pic: null,
  });
  const [loading, setLoading] = useState(false);
  const inputFileRef = useRef();
  const router = useRouter();

  const handleOnChange = (e) => {
    const { name, value } = e.target;
    setData(prev => ({
      ...prev,
      [name]: value
    }));
  }

  const handleOpenFileUploader = () => {
    inputFileRef.current.click();
  }

  const handleUploadProfilePic = (e) => {
    const file = e.target.files[0];
    setData(prev => ({
      ...prev,
      profile_pic: file
    }));
  }

  const handleSubmit = async (e) => {
    e.preventDefault();

    const formData = new FormData();
    formData.append("firstName", data.firstName);
    formData.append("lastName", data.lastName);
    formData.append("location", data.location);
    formData.append("occupation", data.occupation);
    formData.append("email", data.email);
    formData.append("password", data.password);
    if (data.profile_pic) {
      formData.append("profile_pic", data.profile_pic);
    }

    try {
      setLoading(true);
      const response = await axios.post('/api/register', formData);
      toast.success(response.data.message);

      if (response.data.success) {
        setData({
          firstName: "",
          lastName: "",
          location: "",
          occupation: "",
          email: "",
          password: "",
          profile_pic: null,
        });
        router.push("/login");
      }
    } catch (error) {
      toast.error("Registration failed. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section className='container w-full mx-auto p-4 mt-5'>
      <div className='w-full max-w-md bg-white shadow border p-4 mx-auto'>

        <form className='grid gap-4' onSubmit={handleSubmit}>

          <div className='grid lg:grid-cols-2 gap-4'>
            <div className='flex flex-col gap-1'>
              <label htmlFor='firstName'>First Name:</label>
              <input
                type='text'
                name="firstName"
                id='firstName'
                value={data.firstName}
                placeholder='Enter first name'
                onChange={handleOnChange}
                disabled={loading}
                className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
              />
            </div>
            <div className='flex flex-col gap-1'>
              <label htmlFor='lastName'>Last Name:</label>
              <input
                type='text'
                name="lastName"
                id='lastName'
                value={data.lastName}
                placeholder='Enter last name'
                onChange={handleOnChange}
                disabled={loading}
                className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
              />
            </div>
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='location'>Location:</label>
            <input
              type='text'
              name="location"
              id='location'
              value={data.location}
              placeholder='Enter location'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='occupation'>Occupation:</label>
            <input
              type='text'
              name="occupation"
              id='occupation'
              value={data.occupation}
              placeholder='Enter occupation'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input
              type='email'
              name="email"
              id='email'
              value={data.email}
              placeholder='Enter email'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input
              type='password'
              name="password"
              id='password'
              value={data.password}
              placeholder='Enter password'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='profile_pic'>Profile Photo:</label>
            <div className='h-14 bg-gray-100 flex justify-center items-center cursor-pointer border hover:border-blue-700' onClick={handleOpenFileUploader}>
              <input
                type='file'
                id='profile_pic'
                className='hidden'
                ref={inputFileRef}
                onChange={handleUploadProfilePic}
                disabled={loading}
              />
              {data.profile_pic ? (
                <p>{data.profile_pic.name}</p>
              ) : (
                <div className='flex items-center gap-3'>
                  <Image
                    src='/assets/icons/upload.svg'
                    width={25}
                    height={25}
                    alt='upload'
                  />
                  <p className='text-sm'>Upload profile image</p>
                </div>
              )}
            </div>
          </div>

          <button
            type="submit"
            className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>

        </form>

        <div className='my-5'>
          <p>Already have an account? <Link href='/login' className='text-blue-700 hover:text-blue-800 hover:underline'>Login</Link></p>
        </div>

      </div>
    </section>
  );
}

export default Register;


--- File Index 7: src\app\(root)\layout.js ---
import Header from "@/components/Header";
import { Provider } from "@/providers/provider";

export default function RootLayout({ children }) {
    return (
      <main>
        <Provider>
            <Header/>
            { children}
        </Provider>
      </main>
    );
  }
  

--- File Index 8: src\app\(root)\page.js ---
'use client'
import ProfileCard from "@/components/ProfileCard";
import UploadPost from "@/components/UploadPost";
import { ContextData } from "@/providers/provider";
import { useContext, useEffect, useState } from "react";
import axios from 'axios'
import PostDisplay from "@/components/PostDisplay";
import Avatar from "@/components/Avatar";
import Divider from "@/components/Divider";
import handleAddRemoveFriends from "@/helpers/handleAddRemoveFriends";
import toast from 'react-hot-toast'
import News from "@/components/News";

export default function Home() {
  const {user, fetchCurrentUserDetails} = useContext(ContextData)
  const [postData,setPostData] = useState([])
  const [friendsList,setFriendsList] = useState([])

  const fetchPost = async()=>{
    const response = await axios.get("/api/post")
    setPostData(response.data.data || [])
  }

  const fetchFriendsList = async()=>{
    const response = await axios.get('/api/friends')
    setFriendsList(response.data.data)
  }

  useEffect(()=>{
    fetchPost()
    fetchFriendsList()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchFriendsList()
    toast(response.message)
  }

  return (
   <div className="container mx-auto p-4 lg:grid grid-cols-[280px,1fr,280px] gap-7 h-full items-start">
        {/*** current user profile*/}
        <section className="bg-white rounded p-2 lg:sticky lg:top-20">
          <ProfileCard
            _id={user?._id}
            profile_pic={user?.profile_pic}
            firstName={user?.firstName || ''}
            lastName={user?.lastName || ''}
            location={user?.location || ''}
            occupation={user?.occupation || ''}
            friends = {user?.friends || []}
          />
          <hr className="m-3"/>
          <h1 className="font-bold mb-3">Your Connections:</h1>
            <div>
              {
                friendsList.map((friend,index)=>{
                  return(
                    <div key={friend?._id}>
                      <div className="flex items-center gap-3 justify-between">
                        <div className="flex items-center gap-3">
                          <Avatar
                            userId={friend._id}
                            width={40}
                            height={40}
                            imageURL={friend?.profile_pic}
                          />
                          <div>
                            <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                            <p className="text-xs">{friend.occupation}</p>
                          </div>
                        </div>
                        <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                      </div>
                      <Divider/>
                    </div>
                  )
                })
              }
            </div>
        </section>


        {/*** upload post and see post*/}
        <section className="rounded mt-5 lg:mt-0">
            <UploadPost
               _id={user?._id}
               profile_pic={user?.profile_pic}
               callApi={fetchPost}
            />

            <div>
                {
                  postData.map((post,index)=>{
                    return(
                      <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                    )
                  })
                }
            </div>

        </section>


         {/*** ads and friend list*/}
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
            <div className="flex flex-row">
            <News/>
            </div>
        </section>
   </div>
  );
}

--- File Index 9: src\app\(root)\find-friends\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import { ContextData } from '@/providers/provider'
import toast from 'react-hot-toast'

const FindFriends = () => {
  const [allUser,setAllUser] = useState([])
  const {user, fetchCurrentUserDetails} = useContext(ContextData)

  const fetchAllUser = async()=>{
    const response = await axios.get("/api/all-users")
    const friendList = user?.friends || []
    const removeFriends = response.data.data.filter(userDetails => !friendList.includes(userDetails?._id))
    const removeCurrentUser = removeFriends.filter(userDetails => userDetails?._id !== user?._id) 
    setAllUser(removeCurrentUser)
  }

  useEffect(()=>{
    fetchAllUser()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchAllUser()
    toast(response.message)
  }
  return (
    <div className='container mx-auto p-4'>

        <h3 className='font-semibold text-lg mb-3'>Find <span className='text-orange-500 font-extrabold'>New</span> Friends</h3>
        <div className='flex flex-wrap gap-4'>
          {
              allUser.map((user,index)=>{
                return(
                  <div key={index} className='bg-white p-4 flex justify-center flex-col items-center gap-1 min-w-[180px] min-h-[180px]'>
                      <Avatar
                        userId={user?._id}
                        imageURL={user?.profile_pic}
                        width={60}
                        height={60}
                      />
                      <p className='text-lg font-medium capitalize my-0'>{user.firstName} {user.lastName}</p>
                      <p className='text-xs my-0 -mt-2'>{user.occupation}</p>
                      <button className='bg-blue-800 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm mt-2' onClick={()=>handleAddFriend(user?._id)}>Add Friend</button>
                  </div>
                )
              })
          }
        </div>

    </div>
  )
}

export default FindFriends

--- File Index 10: src\app\(root)\message\page.js ---
import React from 'react'

const Message = () => {
  return (
    <div>
      Message
    </div>
  )
}

export default Message

--- File Index 11: src\app\(root)\notification\page.js ---
import React from 'react'

const Notification = () => {
  return (
    <div>Notification</div>
  )
}

export default Notification

--- File Index 12: src\app\(root)\[id]\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import { ContextData } from '@/providers/provider'
import PostDisplay from '@/components/PostDisplay'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import Divider from '@/components/Divider'

const UserProfileDetails = ({ params }) => {
    const [data,setData] = useState(null)
    const [friendslist,setFirendsList] = useState([])
    const [postData,setPostData] = useState([])
    const {user, fetchCurrentUserDetails} = useContext(ContextData)
    const [loading,setLoading] = useState(false)
    
    const fetchUserDetails  = async()=>{
      const payload  = {
        userId : params.id
      }
      setLoading(true)
      const response  = await axios.post("/api/user-details",payload)

      setData(response.data.data)
      setFirendsList(response.data.friends)
      setPostData(response.data.post)
      setLoading(false)
    }

    const handleAddFriend = async(friendId)=>{
      const response = await handleAddRemoveFriends(friendId)
      fetchUserDetails()
    }

    useEffect(()=>{
      fetchUserDetails()
    },[])

    const isDisplayAddFriend = user?.friends?.includes(data?._id) || user?._id === data?._id
  return (
    <div className='container mx-auto'>

        <div className='mt-5 grid gap-10 lg:grid-cols-[2fr,1fr] items-start'>
            {/**user information and post */}
            <div className=''>
                {/**user information */}
                <div className='bg-white p-4'>
                      <div className='h-36 bg-slate-200 rounded mb-14'>
                          <div className='bg-white h-36 w-36 rounded-full translate-x-8 translate-y-1/3 p-1 flex justify-center items-center'>
                              <Avatar
                                imageURL={data?.profile_pic}
                                userId={data?._id}
                                width={130}
                                height={130}
                              />
                          </div>
                      </div>
                      <p className='font-bold text-lg lg:text-2xl capitalize'>{data?.firstName} {data?.lastName}</p>
                      <p className='text-base lg:text-lg'>{data?.occupation}</p>

                      {
                        !isDisplayAddFriend && (
                          <button className='bg-blue-800 hover:bg-blue-700 text-white font-semibold px-5 rounded-full my-3 py-2'>Add Friend</button>
                        )
                      }
                </div>

                {/***post */}
                    <div className='w-full'>
                    {
                      postData.map((post,index)=>{
                        return(
                          <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                        )
                      })
                    }
                  </div> 
            </div>
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
              
              <h1 className="font-bold mb-3">Friends List:</h1>
              <div>
                {
                  friendslist.map((friend,index)=>{
                    return(
                      <div key={friend?._id}>
                        <div className="flex items-center gap-3 justify-between">
                          <div className="flex items-center gap-3">
                              <Avatar
                                userId={friend._id}
                                width={40}
                                height={40}
                                imageURL={friend?.profile_pic}
                              />
                              <div>
                                <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                                <p className="text-xs">{friend.occupation}</p>
                              </div>
                          </div>
                          <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                        </div>

                        <Divider/>
                      </div>
                    )
                  })
                }
              </div>
  
          </section>


        </div>


        {
          loading && (
            <div className='fixed top-0 bottom-0 right-0 left-0 bg-slate-500 bg-opacity-25 flex justify-center items-center'>
              <p className='bg-white px-6 py-2 text-lg'>Loading...</p>
            </div>
          )
        }
    </div>
  )
}

export default UserProfileDetails

--- File Index 13: src\app\api\add-remove-friends\route.js ---
import connectDB from "@/database/db";
import { getUserDetailsFromToken } from "@/helpers/getUserDetailsFromToken";
import userModel from "@/models/userModel";
import { NextResponse } from 'next/server'

connectDB()
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        const { friendId } = await request.json()

        const currentUserFriendList = user.friends || []
        /**add friends */
        if(!currentUserFriendList.includes(friendId)){
             await userModel.updateOne({ _id : user._id },{
                $push : { friends : friendId }
            })


            await userModel.updateOne({ _id : friendId },{
                $push : { friends : user._id?.toString() }
            })

            return NextResponse.json({
                message : "friend added",
                success : true
            })
        }

        //remove friend 
        await userModel.updateOne({ _id : user._id },{
            $pull : { friends : friendId }
        })


        await userModel.updateOne({ _id : friendId },{
            $pull : { friends : user._id?.toString() }
        })

        return NextResponse.json({
            message : "friend remove",
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 14: src\app\api\all-users\route.js ---
import { NextResponse } from "next/server";
import connectDB from "@/database/db";
import userModel from "@/models/userModel";

connectDB()
export async function GET(){
   try {
        const users = await userModel.find()

        const usersDetailsList = users.map(user =>{
            return {
                _id : user._id,
                firstName : user.firstName,
                lastName : user.lastName,
                occupation : user.occupation,
                profile_pic : user.profile_pic
            }
        })

        return NextResponse.json({
            message : "all users",
            data : usersDetailsList,
            success : true
        })
   } catch (error) {
     return NextResponse.json({
        message : error.message || error,
        error : true
     })
   } 
}

--- File Index 15: src\app\api\current-user\route.js ---
import { getUserDetailsFromToken } from "@/helpers/getUserDetailsFromToken";
import { NextResponse } from "next/server";
import connectDB from "@/database/db";

connectDB()
export async function GET(request){
    try {
        const user =  await getUserDetailsFromToken(request)
        
        return NextResponse.json({
            message : "Current user Details",
            data : user
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 16: src\app\api\friends\route.js ---
import { NextResponse } from 'next/server'
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import userModel from '@/models/userModel'


connectDB()
export async function GET(request){
    try {
        const user = await getUserDetailsFromToken(request)

        const friendListId = user.friends || []

        const friendslist = await userModel.find({
            _id : { $in : friendListId }
        })

        const friends =  friendslist.map((userData)=>{
            return{
                _id : userData._id,
                firstName : userData.firstName,
                lastName : userData.lastName,
                occupation : userData.occupation,
                profile_pic : userData.profile_pic
            }
        })

        return NextResponse.json({
            message : 'friend list',
            data :friends,
            success :true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 17: src\app\api\login\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import jwt from 'jsonwebtoken'
import connectDB from '@/database/db'

connectDB() 

export async function POST(request){
    try {
        const { email , password } = await request.json()

        const user = await userModel.findOne({ email })

        if(!user){
            return NextResponse.json({message : "user not exit!"},{status : 400})
        }

        const checkPassword = await bcryptjs.compare(password,user.password)

        if(!checkPassword){
            return NextResponse.json({ message : "Check your password"})
        }

        const tokenData = {
            id : user._id,
            email : user.email
        }

        const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})

        const response =  NextResponse.json({
            token : token,
            message : "Login successfully",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set("token",token,cookiesOption)
        
        return response
 
    } catch (error) {
       return NextResponse.json({ message : error.message || error })
    }
}

--- File Index 18: src\app\api\logout\route.js ---
import { NextResponse } from 'next/server'

export async function GET(){
    try {
        const response = NextResponse.json({
            message : "Logout successfull",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set('token','',cookiesOption)

        return response
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 19: src\app\api\post\route.js ---
import connectDB from '@/database/db'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()
export async function GET(){
    try {
        const post = await postModel.find().populate('userId').sort({ createdAt : -1})

        return NextResponse.json({
            data : post,
            message : "post",
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 20: src\app\api\post\comment\route.js ---
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()


/***save commment */
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const { description , postId } = await request.json()

        const payload  = {
            description :  description,
            userId : user._id
        }

        const commentPost = await postModel.updateOne({ _id : postId},{
            $push : { comment : payload }
        })

        const commentList = await postModel.find({ _id : postId}).populate({
            path : 'comment',
            populate : {
                path : 'userId'
            }
        })

        return NextResponse.json({
            message : "Comment",
            data : commentList,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 21: src\app\api\post\get-comment-for-post\route.js ---
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()


/***save commment */
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const {  postId } = await request.json()

        const commentList = await postModel.findOne({ _id : postId }).populate({
            path : 'comment',
            populate : {
                path : 'userId'
            }
        })

        return NextResponse.json({
            message : "Comment",
            data : commentList,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 22: src\app\api\post\like\route.js ---
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        const { _id } = await request.json()

        const post = await postModel.findOne({ _id : _id })

        /*checkin user id is availabe in like array*/
        if(post.like.includes(user.id)){
            const updatePost = await postModel.updateOne({ _id : _id },{
               $pull : { like : user._id}
            })

            const postData = await postModel.findOne({ _id : _id })
            return NextResponse.json({
                message : "Like",
                data : postData.like,
                success : true
            })
        }

        const updataPost = await postModel.updateOne({ _id : _id },{
            $push : { like : user._id}
         })

        const postData = await postModel.findOne({ _id : _id })

        return NextResponse.json({
            message : 'Liked',
            data : postData.like,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}

--- File Index 23: src\app\api\register\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import uploadImage from '@/helpers/uploadImage'
import connectDB from '@/database/db'

connectDB()

export async function POST(request){
    try {
        const formData = await request.formData()
        const firstName = formData.get('firstName')
        const lastName = formData.get('lastName')
        const location = formData.get('location')
        const occupation = formData.get('occupation')
        const email  = formData.get('email')
        const password = formData.get('password')
        const profilePic = formData.get('profile_pic')

        //checking email id
        const checkEmailid = await userModel.findOne({ email })
        if(checkEmailid){
            return NextResponse.json({ message  : "Already exits user"})
        }

        //password into hash format
        const salt = await bcryptjs.genSalt(10)
        const hashPassword = await bcryptjs.hash(password , salt)

        //upload profile pic in cloudinary
        let uploadProfilePic = ''
        if(profilePic?.name){
            uploadProfilePic = await uploadImage(profilePic)
        } 
        
        const payload = {
            firstName,
            lastName,
            location,
            occupation,
            email,
            password : hashPassword,
            profile_pic : uploadProfilePic.url,
            profileViews : Math.floor(Math.random() * 1000),  
            profileImpressions : Math.floor(Math.random() * 1000),
        }

        const user  = new userModel(payload)
        const saveUserData = await user.save()

        return NextResponse.json({message : "User created successfully", data : saveUserData, success : true })

    } catch (error) {
        return NextResponse.json({ message : error.message || error })
    }
}

--- File Index 24: src\app\api\upload-post\route.js ---
import connectDB from '@/database/db'
import { NextResponse } from 'next/server'
import postModel from '@/models/postModel'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import uploadImage from '@/helpers/uploadImage'


connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const formdata = await request.formData()
        const description = formdata.get("description")
        const image = formdata.get("image")

        let postUpload = ''
        if(image){
            postUpload = await uploadImage(image)
        } 

        const payload =  {
            image : postUpload.url,
            description : description,
            userId : user._id
        }

        const post = new postModel(payload)
        const savePost = await post.save()

        return NextResponse.json({
            message : "Upload successfully",
            success : true,
            data : savePost
        })

    } catch (error) {
        return NextResponse.json({ message : error.message || message })
    }   
}

--- File Index 25: src\app\api\user-details\route.js ---
import { NextResponse } from 'next/server'
import connectDB from '@/database/db'
import userModel from '@/models/userModel'
import postModel from '@/models/postModel'

connectDB()

export async function POST(request){
    try {
        const { userId } = await request.json()

        //user
        const user   = await userModel.findOne({ _id : userId})


        //friends
        const friendListId = user.friends || []
        const friendslist = await userModel.find({
            _id : { $in : friendListId }
        })
        const friends =  friendslist.map((userData)=>{
            return{
                _id : userData._id,
                firstName : userData.firstName,
                lastName : userData.lastName,
                occupation : userData.occupation,
                profile_pic : userData.profile_pic
            }
        })

        //post
        const post = await postModel.find({ userId : userId }).populate('userId').sort({ createdAt : -1})

        return NextResponse.json({
            data : user,
            friends : friends,
            post : post,
            message : 'user details',
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File Index 26: src\components\Avatar.js ---
import React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar

--- File Index 27: src\components\Divider.js ---
import React from 'react'

const Divider = () => {
  return (
    <div className='bg-slate-200 p-[0.5px] my-3'>
    </div>
  )
}

export default Divider

--- File Index 28: src\components\Header.js ---
'use client'
import React, { useContext, useState } from 'react'
import Image from 'next/image'
import { headerNavLink } from '@/constants'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import axios from 'axios'
import toast from 'react-hot-toast'
import { useRouter } from 'next/navigation'
import { ContextData } from '@/providers/provider'
import Avatar from './Avatar'
import { Search } from 'lucide-react'

const Header = () => {
    const path = usePathname()
    const router = useRouter()
    const [openUserMenu, setOpenUserMenu] = useState(false)
    const { user, fetchCurrentUserDetails } = useContext(ContextData)

    const handleOpenClose = () => {
        setOpenUserMenu((prev) => !prev)
    }

    const handleUserLogout = async () => {
        const response = await axios.get('/api/logout')
        setOpenUserMenu(false)
        toast(response?.data.message)
        router.push("/login")
    }

    return (
        <header className='h-16 bg-white sticky z-40 shadow top-0'>
            <div className='container mx-auto h-full flex items-center px-4 justify-between'>
                <div className='grid grid-cols-[170px,1fr] items-center'>
                    <Link href={"/"}>
                        <Image 
                            src={'/logo.png'}
                            width={190}
                            height={70}
                            alt='logo'
                        />
                    </Link>

                    {/* Search input */}
                    <div className='w-full items-center gap-2 border bg-slate-100 px-1 rounded hidden lg:flex'>
                        <input 
                            type='text' 
                            placeholder='Search here...'
                            className='w-full max-w-52 bg-slate-100 py-1 px-2 outline-none'
                        />
                        <Search />
                    </div>
                </div>

                <div className='flex items-center gap-10 h-full'>
                    {/* Navbar */}
                    <nav className='hidden lg:flex items-center gap-4 h-full'>
                        {headerNavLink.map((navlink, index) => { 
                            const isActive = path === navlink.route
                            const Icon = navlink.icon
                            return (
                                <Link 
                                    href={navlink.route}
                                    key={index}
                                    className={`flex flex-col justify-center items-center gap-1 h-full px-4 ${isActive ? 'bg-slate-100' : ''}`}
                                >
                                    <Icon />
                                    <p className='text-sm'>{navlink.label}</p>
                                </Link>
                            )
                        })}
                    </nav>

                    <div>
                        {/* Current user login image */}
                        <div className='flex flex-col justify-center items-center cursor-pointer relative'>
                            <div onClick={handleOpenClose} className='flex flex-col justify-center items-center'>
                                <Avatar
                                    userId={user?._id}
                                    imageURL={user?.profile_pic}
                                    width={28}
                                    height={28}
                                    disable={true}
                                />
                                <p className='text-sm'>Me</p>
                            </div>
                            
                            {/* User menu */}
                            {openUserMenu && (
                                <div className='shadow absolute top-14 right-0 min-w-60 p-4 rounded bg-white'>
                                    <div className='font-semibold text-center flex flex-col justify-center items-center'>
                                        <Avatar
                                            userId={user?._id}
                                            imageURL={user?.profile_pic}
                                            width={45}
                                            height={45}
                                            extraWidth={20}
                                            extraHeight={20}
                                        />
                                        <p className='text-lg'>
                                            { user?.firstName + " " + user?.lastName }
                                        </p>
                                        <p className='text-sm'>
                                            {user?.occupation}
                                        </p>
                                    </div>

                                    <div className='p-[0.5px] my-1 bg-slate-200'></div>

                                    {/* Mobile responsive */}
                                    <nav className='flex lg:hidden justify-center flex-col gap-2 h-full'>
                                        {headerNavLink.map((navlink, index) => { 
                                            const isActive = path === navlink.route
                                            const Icon = navlink.icon
                                            return (
                                                <Link 
                                                    href={navlink.route}
                                                    key={index}
                                                    className={`flex flex-row gap-2 h-full px-4 py-3 ${isActive ? 'bg-slate-100' : ''}`}
                                                    onClick={handleOpenClose}
                                                >
                                                    <Icon />
                                                    <p className='text-sm'>{navlink.label}</p>
                                                </Link>
                                            )
                                        })}
                                    </nav>

                                    <button className='bg-red-600 text-white rounded hover:bg-red-700 w-full py-1' onClick={handleUserLogout}>Logout</button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        </header>
    )
}

export default Header


--- File Index 29: src\components\News.js ---
import { Info } from 'lucide-react'
import React from 'react'

const newsItems = [
  {
    heading: "India win 2024 T20 world cup",
    subHeading: "1h ago - 524 readers"
  },
  {
    heading: "Deforestation is still Increasing",
    subHeading: "4h ago - 239 readers"
  },
  {
    heading: "Rise in price of gold by 2%",
    subHeading: "4h ago - 234 readers"
  },
  {
    heading: "Maharashtra's Rainfall goes beyond the limit",
    subHeading: "4h ago - 112 readers"
  },
]

const News = () => {
  return (
    <div className='hidden md:block w-full bg-white h-fit rounded-lg border border-gray-300'>
      <div className='flex items-center justify-between p-3'>
        <h1 className='font-medium'>LinkedIn News</h1>
        <Info size={18} />
      </div>
      <div className='grid grid-cols-1 gap-4 p-3'>
        {newsItems.map((item, index) => (
          <div key={index} className='hover:bg-gray-200 cursor-pointer p-2 rounded'>
            <h1 className='text-sm font-medium'>{item.heading}</h1>
            <p className='text-xs text-gray-600'>{item.subHeading}</p>
          </div>
        ))}
      </div>
    </div>
  )
}

export default News


--- File Index 30: src\components\PostDisplay.js ---
import React, { useContext, useEffect, useState } from 'react'
import Avatar from './Avatar'
import Image from 'next/image'
import { ContextData } from '@/providers/provider'
import axios from 'axios'
import { MessageSquare, Share, UserPlus } from 'lucide-react'

const PostDisplay = ({ data ,handleAddFriend }) => {
    const [likeData,setLikeData] = useState(data?.like || [])
    const [commentData,setCommentData] = useState(data?.comment || [])
    const [openComment,setOpenComment] = useState(false)
    const [comment,setComment] = useState('')

    const {user, fetchCurrentUserDetails} = useContext(ContextData)


    const handleLikePost = async()=>{
        const payload = {
            _id : data?._id
        }
        const response = await axios.post('/api/post/like',payload)

        setLikeData(response.data.data)
    }


    const handleOpenCloseComment = () =>{
        setOpenComment(preve => !preve)
    }

    const fetchCommentData = async() =>{
        const payload  = {
            postId : data?._id
        }
        const response = await axios.post("api/post/get-comment-for-post",payload)

        setCommentData(response.data.data.comment || [])
    }

    useEffect(()=>{
        if(openComment){
            fetchCommentData()
        }
    },[])


    const handleuploadComment = async() =>{
        const payload = {
            description : comment,
            postId : data?._id
        }
        if(comment){
            const response  = await axios.post("api/post/comment",payload)
            setComment('')
            fetchCommentData()
        }
        
    }
    


    const currentUserLiked = likeData.includes(user?._id)
    const isDisplayAddFriend = user?.friends?.includes(data?.userId?._id) || user?._id === data?.userId?._id
  return (
    <div className='bg-white p-4 my-6'>
        <div className='flex gap-3 items-center justify-between'>
            <div className='flex gap-3 items-center'>
                <Avatar
                    userId={data.userId._id}
                    imageURL={data.userId.profile_pic}
                    width={40}
                    height={40}
                />
                <div>
                    <p className='font-bold'>{data.userId.firstName} {data.userId.lastName}</p>
                    <p className='text-xs'>{data.userId.occupation}</p>
                </div>
            </div>

            {
                !isDisplayAddFriend && (
                    <div className='bg-white shadow-md p-2 rounded-full flex justify-center items-center cursor-pointer hover:bg-blue-700' onClick={()=>handleAddFriend(data?.userId?._id)}>
                        <UserPlus/>
                    </div>
                )
            }
           
        </div>

        <p className='py-3'>
            {data.description}
        </p>

        <div className='w-full h-full'>
            {
                data.image && (
                    <Image 
                        src={data.image}
                        width={1000}
                        height={1000}
                        alt='post'
                    />
                )
            }
        </div>


        <div className='text-sm flex items-center justify-between mt-3'>
             {/**like count */}
            <div>
                {likeData.length  === 0 ? "You're first to like" : likeData.length + " Likes"  }
            </div>

            {/**comment count */}
            <div>
                {commentData.length} comment
            </div>

        </div>

        <div className='p-[0.5px] bg-slate-200'></div>

        
        <div className='py-1 flex justify-between gap-3'>
             {/**like */}
             <div className='flex items-center gap-1 cursor-pointer' onClick={handleLikePost}>
                {
                    currentUserLiked ? (
                        <Image
                            src={'/liked.svg'}
                            width={20}
                            height={20}
                            alt='like' 
                        />
                    ) : (
                        <Image
                        src={'/like.svg'}
                        width={20}
                        height={20}
                        alt='like' 
                        />
                    )
                }
                
                <p  className={currentUserLiked && 'text-blue-800 font-semibold'}>Like</p>
             </div>


              {/**comment */}
              <div className='flex items-center gap-1 cursor-pointer hover:text-blue-700' onClick={handleOpenCloseComment}>
                    <MessageSquare/>
                    <p>Comment</p>  
              </div>


            {/**share */}
            <div>
                <div className='flex items-center gap-1 cursor-pointer'>
                <Share/>
                <p>Share</p> 
                </div>
            </div>
        </div>


        {/****display all the comment */}
        {
            openComment && (
                <div className='p-4 bg-white w-full'>
                     <div className='flex items-center gap-4 w-full'>
                        <Avatar
                            userId={user._id}
                            imageURL={user.profile_pic}
                            width={40}
                            height={40}
                            alt={user.firstName}
                        />
                        <div className='w-full flex gap-1'>
                            <input 
                                type='text' 
                                placeholder='type comment here...' 
                                className='bg-slate-100 rounded-full px-4 py-2 w-full outline-none' 
                                onChange={(e)=>setComment(e.target.value)}
                                value={comment}
                            />
                            <button className='bg-blue-700 text-white text-sm px-3 py-1 rounded-full' onClick={handleuploadComment}>Send</button>
                        </div>
                    </div>


                    {/**list of comment */}
                    <div className='mt-3'>
                        {
                            commentData.map((comment,index)=>{
                                return(
                                    <div className='ml-5 p-2 border-b' key={comment?._id}>
                                        <div className='flex gap-3 items-center'>
                                            <Avatar
                                                userId={comment?.userId?._id}
                                                imageURL={comment?.userId?.profile_pic}
                                                width={30}
                                                height={30}
                                                alt={comment?.userId?.firstName}
                                            />
                                            <div className='flex flex-col'>
                                                <p className='font-semibold text-sm'>{comment?.userId?.firstName} {comment?.userId?.lastName}</p>
                                                <p className='text-xs -mt-1'>{comment?.userId?.occupation}</p>
                                            </div>
                                        </div> 
                                        <div className='text-sm py-1 px-2'>
                                            {comment.description}
                                        </div>   
                                    </div>
                                )
                            })
                        }
                    </div>

                    
                </div>
            )
        }
    </div>
  )
}

export default PostDisplay

--- File Index 31: src\components\ProfileCard.js ---
'use client'
import React from 'react'
import Avatar from './Avatar'
import { LucideUserPlus, MapPinIcon } from 'lucide-react'

const ProfileCard = ({_id, firstName, lastName, occupation, location, profile_pic, friends = [], profileViews = 0 , profileImpressions = 0  }) => {
  return (
    <div className='p-2'>
      {/**image  */}
        <div className='bg-slate-200 h-16 mb-10'>
            <div className='w-16 h-16 rounded-full bg-white mx-auto translate-y-8 shadow-md'>
                <Avatar
                    userId={_id}
                    imageURL={profile_pic}
                    width={64}
                    height={64}
                />
            </div>
        </div>

        {/**name and occupation */}
        <div className='text-center'>
            <p className='font-bold text-lg'>{firstName +" "+lastName}</p> 
            <p className='text-sm'>{occupation}</p>
        </div>

        <div className='p-[0.5px] bg-slate-200 my-2'></div>

          {/**name and friends */}
         <div className='grid gap-1'>
              <div className='flex items-center gap-3'>
                <MapPinIcon/>
                <p>{location}</p>
              </div>
              <div  className='flex items-center gap-3'>
                <LucideUserPlus/>
                <p >Friends <span className='text-xs'>({friends.length})</span></p>
              </div>
         </div>


         <div className='p-[0.5px] bg-slate-200 my-2'></div>

        {/****profile views and profile impresss */}
        <div className='grid gap-1'>
            <div className='flex justify-between items-center gap-3'>
                <p>Profile views</p>
                <p>{profileViews}</p>
            </div>

            <div className='flex justify-between items-center gap-3'>
                <p>Profile impressions</p>
                <p>{profileImpressions}</p>
            </div>

        </div>

     
    </div>
  )
}

export default ProfileCard

--- File Index 32: src\components\UploadPost.js ---
'use client'
import React, { useRef, useState } from 'react'
import Avatar from './Avatar'
import Divider from './Divider'
import toast from 'react-hot-toast'
import axios from 'axios'
import { CrossIcon, ImageIcon } from 'lucide-react'

const UploadPost = ({ _id, profile_pic,callApi }) => {
    const [data, setData] = useState({
        description: "",
        image: ""
    })
    const inputFileRef = useRef()
    const [loading,setLoading] = useState(false)

    const handleOpenFileExplore = () =>{
        inputFileRef.current.click()
    }

    const handleOnChange = (e) => {
        const { value, name } = e.target

        setData((preve) => {
            return {
                ...preve,
                [name]: value
            }
        })
    }

    const handleUploadFile = (e)=>{
        const file = e.target.files[0]

        setData((preve)=>{
            return{
                ...preve,
                image : file
            }
        })
    }
    const handleClearUpload = (e)=>{
        setData((preve)=>{
            return{
                ...preve,
                image : ""
            }
        })
    }

    const handlePost = async(e)=>{
        e.preventDefault()

        if(!data.description){
            toast("Please type something....")
            return
        }

        const formData = new FormData()
        formData.set("description",data.description)
        formData.set("image",data.image)
        setLoading(true)
        const response = await axios.post('/api/upload-post',formData)
        setLoading(false)
        toast(response.data.message)
        if(response.data.success){
            setData({
                description: "",
                image: ""
            })
            callApi()
        }


    }

    return (
        <div className='bg-white p-4 rounded'>
            <div className='flex gap-4 items-start'>
                <Avatar
                    imageURL={profile_pic}
                    width={50}
                    height={50}
                    userId={_id}
                />

                <div className='w-full'>
                    <textarea
                        name='description'
                        placeholder='type here...'
                        className='bg-slate-100 px-4 py-2 w-full outline-none rounded resize-none'
                        value={data.description}
                        onChange={handleOnChange}
                    />
                    {
                        data?.image && (
                            <div className='bg-slate-100 border text-center relative py-2 px-4'>
                                <div className='w-5 h-5 text-sm hover:text-red-600 cursor-pointer rounded-full absolute right-0 top-0' onClick={handleClearUpload}>
                                    <CrossIcon/>
                                </div>
                                {data?.image?.name}
                            </div>
                        )
                    }
                    
                </div>
            </div>



            <Divider />

            <div className='flex justify-between items-center'>
                <div className='flex items-center gap-2 cursor-pointer' onClick={handleOpenFileExplore}>
                    <ImageIcon/>
                    <p className='hover:text-blue-700'>Image</p>

                    <input type='file' className='hidden' ref={inputFileRef} onChange={handleUploadFile}/>
                </div>

                <button className='bg-blue-700 px-5 py-1 text-white rounded-full' onClick={handlePost}>Post</button>
            </div>



            {/***loading state */}
            {
                loading && (
                <div className='fixed bg-slate-200 bg-opacity-60 top-0 right-0 left-0 bottom-0 w-full h-full flex justify-center items-center'>
                    <p className='bg-white p-4'>Loading....</p>
                </div>
                )
            }
            
        </div>
    )
}

export default UploadPost

--- File Index 33: src\constants\index.js ---
import { Home, Users, MessageSquare, Bell } from 'lucide-react'

export const headerNavLink = [
    {
        label: 'Home',
        icon: Home,
        route: '/'
    },
    {
        label: 'My Network',
        icon: Users,
        route: '/find-friends'
    },
    {
        label: 'Messaging',
        icon: MessageSquare,
        route: '/message'
    },
    {
        label: 'Notifications',
        icon: Bell,
        route: '/notification'
    }
]


--- File Index 34: src\database\db.js ---
import mongoose from "mongoose";

async function connectDb(){
    try {
        await mongoose.connect(process.env.MONGO_URI)
        const dbConnection = mongoose.connection
        dbConnection.on('db connected',()=>{
            console.log("connect to mongoDB")
        })
        dbConnection.on('error',(error)=>{
            console.log("connection failed "+error)
        })
    } catch (error) {
        console.log("Error in Database",error)
    }
}

export default connectDb

--- File Index 35: src\helpers\getUserDetailsFromToken.js ---
import connectDB from '@/database/db'
import userModel from '@/models/userModel'
import jwt from 'jsonwebtoken'

connectDB()
export const getUserDetailsFromToken = async(request) =>{
    try {
        const token = request.cookies.get('token')?.value || ''
        if(token){
            const userData = await jwt.verify(token,process.env.SECRET_KEY_TOKEN)

            const user = await userModel.findOne({ _id : userData.id })
            return user
        }

        return token

    } catch (error) {
        return error
    }
}

--- File Index 36: src\helpers\handleAddRemoveFriends.js ---
import axios from 'axios'

const handleAddRemoveFriends = async(friendId) =>{
    const payload = {
        friendId : friendId
    }
    const response = await axios.post('/api/add-remove-friends',payload)

    return response.data
}

export default handleAddRemoveFriends

--- File Index 37: src\helpers\uploadImage.js ---
import {v2 as cloudinary} from 'cloudinary';
          
cloudinary.config({ 
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME, 
  api_key: process.env.CLOUDINARY_API_KEY, 
  api_secret: process.env.CLOUDINARY_API_SECRET
});


const uploadImage = async(file)=>{
    const buffer = Buffer.from(await file.arrayBuffer())

    const uploadFileData = await new Promise((resolve,reject)=>{
        cloudinary.uploader.upload_stream({ folder : 'linkedIn_clone'},(error,uploadResult)=>{
            return resolve(uploadResult)
        }).end(buffer)
    })

    return uploadFileData
}

export default uploadImage

--- File Index 38: src\models\postModel.js ---
import mongoose , { Schema } from 'mongoose'

const commentSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    }
},{
    timestamps : true
})


const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    image : {
        type : String,
        default : ""
    },
    userId : {
        type : Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    },
    comment : [commentSchema]
},{
    timestamps : true
})


const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel

--- File Index 39: src\models\userModel.js ---
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        min : 3,
        max : 100,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        min : 3,
        max : 100,
        required : [true, "Provide last name"]
   },
   location : {
        type : String,
        default : ""
   },
   occupation : {
        type : String,
        default : ""
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   },
   profile_pic : {
        type : String,
        default : ""
   },
   profileViews : {
        type : Number,
        min : 0,
        default : 0
   },
   profileImpressions : {
        type : Number,
        min : 0,
        default : 0
   },
   friends : {
     type : Array,
     default : []
   }
},{
    timeStamps : true
})


const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)


export default userModel

--- File Index 40: src\providers\provider.js ---
'use client'

import axios from "axios";
import { createContext, useEffect, useState } from "react";

export const ContextData = createContext(null)

export const Provider = ({children}) =>{
    const [user,setData] = useState(null)

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return(
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    )
}



Analyze the codebase context.
Identify the top 5-10 core most important abstractions to help those new to the codebase.

For each abstraction, provide:
1. A concise `name`.
2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.
3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.

List of file indices and paths present in the context:
- 0 # README.md
- 1 # tailwind.config.js
- 2 # src\middleware.js
- 3 # src\app\layout.js
- 4 # src\app\(auth)\layout.js
- 5 # src\app\(auth)\login\page.js
- 6 # src\app\(auth)\register\page.js
- 7 # src\app\(root)\layout.js
- 8 # src\app\(root)\page.js
- 9 # src\app\(root)\find-friends\page.js
- 10 # src\app\(root)\message\page.js
- 11 # src\app\(root)\notification\page.js
- 12 # src\app\(root)\[id]\page.js
- 13 # src\app\api\add-remove-friends\route.js
- 14 # src\app\api\all-users\route.js
- 15 # src\app\api\current-user\route.js
- 16 # src\app\api\friends\route.js
- 17 # src\app\api\login\route.js
- 18 # src\app\api\logout\route.js
- 19 # src\app\api\post\route.js
- 20 # src\app\api\post\comment\route.js
- 21 # src\app\api\post\get-comment-for-post\route.js
- 22 # src\app\api\post\like\route.js
- 23 # src\app\api\register\route.js
- 24 # src\app\api\upload-post\route.js
- 25 # src\app\api\user-details\route.js
- 26 # src\components\Avatar.js
- 27 # src\components\Divider.js
- 28 # src\components\Header.js
- 29 # src\components\News.js
- 30 # src\components\PostDisplay.js
- 31 # src\components\ProfileCard.js
- 32 # src\components\UploadPost.js
- 33 # src\constants\index.js
- 34 # src\database\db.js
- 35 # src\helpers\getUserDetailsFromToken.js
- 36 # src\helpers\handleAddRemoveFriends.js
- 37 # src\helpers\uploadImage.js
- 38 # src\models\postModel.js
- 39 # src\models\userModel.js
- 40 # src\providers\provider.js

Format the output as a YAML list of dictionaries:

```yaml
- name: |
    Query Processing
  description: |
    Explains what the abstraction does.
    It's like a central dispatcher routing requests.
  file_indices:
    - 0 # path/to/file1.py
    - 3 # path/to/related.py
- name: |
    Query Optimization
  description: |
    Another core concept, similar to a blueprint for objects.
  file_indices:
    - 5 # path/to/another.js
# ... up to 10 abstractions
```
2025-05-30 19:09:12,248 - INFO - RESPONSE (from cache): ```yaml
- name: User Authentication and Authorization
  description: |
    This abstraction manages user login, registration, and access control. Think of it as the bouncer at a club, verifying IDs (credentials) and deciding who gets in and where they're allowed to go based on roles. It ensures that only authenticated users can access certain parts of the application. The `middleware` checks for existing authentication tokens to redirect users appropriately.
  file_indices:
    - 2 # src\middleware.js
    - 5 # src\app\(auth)\login\page.js
    - 6 # src\app\(auth)\register\page.js
    - 17 # src\app\api\login\route.js
    - 18 # src\app\api\logout\route.js
    - 23 # src\app\api\register\route.js

- name: User Data Model
  description: |
    This defines the structure and properties of a user, such as name, email, password, and profile picture. It is like a blueprint for creating user objects in the database. The user model ensures all user data is consistent and contains the necessary information to represent a user in the application.
  file_indices:
    - 39 # src\models\userModel.js

- name: API Route Handlers
  description: |
    These are functions that handle incoming HTTP requests to the server.  Think of them as waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals).  Each handler is responsible for a specific endpoint, like `/api/login` or `/api/register`.
  file_indices:
    - 13 # src\app\api\add-remove-friends\route.js
    - 14 # src\app\api\all-users\route.js
    - 15 # src\app\api\current-user\route.js
    - 16 # src\app\api\friends\route.js
    - 17 # src\app\api\login\route.js
    - 18 # src\app\api\logout\route.js
    - 19 # src\app\api\post\route.js
    - 20 # src\app\api\post\comment\route.js
    - 21 # src\app\api\post\get-comment-for-post\route.js
    - 22 # src\app\api\post\like\route.js
    - 23 # src\app\api\register\route.js
    - 24 # src\app\api\upload-post\route.js
    - 25 # src\app\api\user-details\route.js

- name: Post Data Model
  description: |
    This abstraction represents a social media post, including its content (description, image), the user who created it, likes, and comments. It's the structure of data of each post. It's like a template to standardize new data that is added to the system.
  file_indices:
    - 38 # src\models\postModel.js

- name: Context Provider (ContextData)
  description: |
    This is a way to share data (like the current user) across different components without having to pass it down manually through props. Think of it like a central information hub. Components can subscribe to the context to get the latest data and react to changes.
  file_indices:
    - 40 # src\providers\provider.js
    - 8 # src\app\(root)\page.js
    - 9 # src\app\(root)\find-friends\page.js
    - 12 # src\app\(root)\[id]\page.js
    - 30 # src\components\PostDisplay.js
    - 28 # src\components\Header.js

- name: Avatar Component
  description: |
    A reusable UI component to display user profile pictures. It abstracts away the complexity of image loading and provides a consistent look and feel throughout the application.  It also handles navigation to the user's profile page when clicked. It's like a standardized frame for displaying user photos.
  file_indices:
    - 26 # src\components\Avatar.js
    - 8 # src\app\(root)\page.js
    - 9 # src\app\(root)\find-friends\page.js
    - 12 # src\app\(root)\[id]\page.js
    - 28 # src\components\Header.js
    - 30 # src\components\PostDisplay.js
    - 31 # src\components\ProfileCard.js
    - 32 # src\components\UploadPost.js

- name: Database Connection
  description: |
    This abstraction handles the connection to the MongoDB database. It's like the plumber connecting your house to the city's water supply. It ensures that the application can reliably read and write data to the database.
  file_indices:
    - 34 # src\database\db.js

- name: Handle Add Remove Friends Helper
  description: |
    This helper function encapsulates the logic for adding and removing friends.  It makes a request to the API to perform the add/remove operation.  It's like a dedicated tool for managing friendships in the application. It avoids code duplication when adding/removing friends from different components.
  file_indices:
    - 36 # src\helpers\handleAddRemoveFriends.js
    - 8 # src\app\(root)\page.js
    - 9 # src\app\(root)\find-friends\page.js
    - 12 # src\app\(root)\[id]\page.js

- name: Image Upload Helper
  description: |
    This helper function handles uploading images to Cloudinary. It simplifies the process of uploading images and provides a consistent way to manage image storage.
  file_indices:
    - 37 # src\helpers\uploadImage.js
    - 23 # src\app\api\register\route.js
    - 24 # src\app\api\upload-post\route.js
```
2025-05-30 19:09:12,264 - INFO - PROMPT: 
Based on the following abstractions and relevant code snippets from the project `LinkedIn`:

List of Abstraction Indices and Names:
0 # User Authentication and Authorization
1 # User Data Model
2 # API Route Handlers
3 # Post Data Model
4 # Context Provider (ContextData)
5 # Avatar Component
6 # Database Connection
7 # Handle Add Remove Friends Helper
8 # Image Upload Helper

Context (Abstractions, Descriptions, Code):
Identified Abstractions:\n- Index 0: User Authentication and Authorization (Relevant file indices: [2, 5, 6, 17, 18, 23])\n  Description: This abstraction manages user login, registration, and access control. Think of it as the bouncer at a club, verifying IDs (credentials) and deciding who gets in and where they're allowed to go based on roles. It ensures that only authenticated users can access certain parts of the application. The `middleware` checks for existing authentication tokens to redirect users appropriately.
\n- Index 1: User Data Model (Relevant file indices: [39])\n  Description: This defines the structure and properties of a user, such as name, email, password, and profile picture. It is like a blueprint for creating user objects in the database. The user model ensures all user data is consistent and contains the necessary information to represent a user in the application.
\n- Index 2: API Route Handlers (Relevant file indices: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25])\n  Description: These are functions that handle incoming HTTP requests to the server.  Think of them as waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals).  Each handler is responsible for a specific endpoint, like `/api/login` or `/api/register`.
\n- Index 3: Post Data Model (Relevant file indices: [38])\n  Description: This abstraction represents a social media post, including its content (description, image), the user who created it, likes, and comments. It's the structure of data of each post. It's like a template to standardize new data that is added to the system.
\n- Index 4: Context Provider (ContextData) (Relevant file indices: [8, 9, 12, 28, 30, 40])\n  Description: This is a way to share data (like the current user) across different components without having to pass it down manually through props. Think of it like a central information hub. Components can subscribe to the context to get the latest data and react to changes.
\n- Index 5: Avatar Component (Relevant file indices: [8, 9, 12, 26, 28, 30, 31, 32])\n  Description: A reusable UI component to display user profile pictures. It abstracts away the complexity of image loading and provides a consistent look and feel throughout the application.  It also handles navigation to the user's profile page when clicked. It's like a standardized frame for displaying user photos.
\n- Index 6: Database Connection (Relevant file indices: [34])\n  Description: This abstraction handles the connection to the MongoDB database. It's like the plumber connecting your house to the city's water supply. It ensures that the application can reliably read and write data to the database.
\n- Index 7: Handle Add Remove Friends Helper (Relevant file indices: [8, 9, 12, 36])\n  Description: This helper function encapsulates the logic for adding and removing friends.  It makes a request to the API to perform the add/remove operation.  It's like a dedicated tool for managing friendships in the application. It avoids code duplication when adding/removing friends from different components.
\n- Index 8: Image Upload Helper (Relevant file indices: [23, 24, 37])\n  Description: This helper function handles uploading images to Cloudinary. It simplifies the process of uploading images and provides a consistent way to manage image storage.
\n\nRelevant File Snippets (Referenced by Index and Path):\n--- File: 2 # src\middleware.js ---\nimport { NextResponse } from 'next/server'
 
// This function can be marked `async` if using `await` inside
export function middleware(request) {
    const path = request.nextUrl.pathname

    const isPublicPath = path === '/login' || path === '/register'

    const token = request.cookies.get('token')?.value || ''

    if(isPublicPath && token){
        return NextResponse.redirect(new URL('/',request.nextUrl))
    }

    if(!isPublicPath && !token){
        return NextResponse.redirect(new URL('/login',request.nextUrl))
    }

}
 


// See "Matching Paths" below to learn more
export const config = {
  matcher: [    
    '/login',
    '/register',
    '/'
  ],
}\n\n--- File: 5 # src\app\(auth)\login\page.js ---\n'use client'

import React, {  useState } from 'react'
import Link from 'next/link'
import axios from 'axios'
import toast from 'react-hot-toast';
import { useRouter } from 'next/navigation'

const Login = () => {
  const [data,setData] = useState({
    email : "",
    password : "",
  })
  const [loading,setLoading] = useState(false)
  const router = useRouter()

  const handleOnChange =  (e) =>{
    const {name , value } = e.target

    setData((preve)=>{
      return{
          ...preve,
           [name] : value
      }
    })
  }

  const handleSubmit = async(e) =>{
    e.preventDefault()

    const response = await axios.post('/api/login',data)
    toast(response.data.message)


    if(response.data.success){
      setData({
        email : "",
        password : "",
      })
      router.push("/")
    }
    
  }


  return (
    <section className='container w-full mx-auto p-1 mt-5'>
    <div className='w-full max-w-md bg-white shadow border p-4 mx-auto'>
        <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
          
          <div className='flex flex-col gap-1'>
                <label htmlFor='email'>Email:</label>
                <input
                  type='email'
                  name="email"
                  id='email'
                  value={data.email}
                  placeholder='enter email'
                  onChange={handleOnChange}
                  disabled={loading}
                  className='bg-slate-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
                />
          </div>


          <div className='flex flex-col gap-1'>
                <label htmlFor='password'>Password:</label>
                <input
                  type='password'
                  name="password"
                  id='password'
                  value={data.password}
                  placeholder='enter password'
                  onChange={handleOnChange}
                  disabled={loading}
                  className='bg-slate-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
                />
          </div>

          <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
        </form>

        <div className='my-5'>
          <p>Create new account ? <Link href={'/register'} className='text-blue-700 hover:text-blue-800 hover:underline'>Register</Link></p>
        </div>
    </div>
</section>
  )
}

export default Login\n\n--- File: 6 # src\app\(auth)\register\page.js ---\n'use client'

import React, { useRef, useState } from 'react'
import Image from 'next/image'
import Link from 'next/link'
import axios from 'axios'
import toast from 'react-hot-toast';
import { useRouter } from 'next/navigation'

const Register = () => {
  const [data, setData] = useState({
    firstName: "",
    lastName: "",
    location: "",
    occupation: "",
    email: "",
    password: "",
    profile_pic: null,
  });
  const [loading, setLoading] = useState(false);
  const inputFileRef = useRef();
  const router = useRouter();

  const handleOnChange = (e) => {
    const { name, value } = e.target;
    setData(prev => ({
      ...prev,
      [name]: value
    }));
  }

  const handleOpenFileUploader = () => {
    inputFileRef.current.click();
  }

  const handleUploadProfilePic = (e) => {
    const file = e.target.files[0];
    setData(prev => ({
      ...prev,
      profile_pic: file
    }));
  }

  const handleSubmit = async (e) => {
    e.preventDefault();

    const formData = new FormData();
    formData.append("firstName", data.firstName);
    formData.append("lastName", data.lastName);
    formData.append("location", data.location);
    formData.append("occupation", data.occupation);
    formData.append("email", data.email);
    formData.append("password", data.password);
    if (data.profile_pic) {
      formData.append("profile_pic", data.profile_pic);
    }

    try {
      setLoading(true);
      const response = await axios.post('/api/register', formData);
      toast.success(response.data.message);

      if (response.data.success) {
        setData({
          firstName: "",
          lastName: "",
          location: "",
          occupation: "",
          email: "",
          password: "",
          profile_pic: null,
        });
        router.push("/login");
      }
    } catch (error) {
      toast.error("Registration failed. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section className='container w-full mx-auto p-4 mt-5'>
      <div className='w-full max-w-md bg-white shadow border p-4 mx-auto'>

        <form className='grid gap-4' onSubmit={handleSubmit}>

          <div className='grid lg:grid-cols-2 gap-4'>
            <div className='flex flex-col gap-1'>
              <label htmlFor='firstName'>First Name:</label>
              <input
                type='text'
                name="firstName"
                id='firstName'
                value={data.firstName}
                placeholder='Enter first name'
                onChange={handleOnChange}
                disabled={loading}
                className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
              />
            </div>
            <div className='flex flex-col gap-1'>
              <label htmlFor='lastName'>Last Name:</label>
              <input
                type='text'
                name="lastName"
                id='lastName'
                value={data.lastName}
                placeholder='Enter last name'
                onChange={handleOnChange}
                disabled={loading}
                className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
              />
            </div>
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='location'>Location:</label>
            <input
              type='text'
              name="location"
              id='location'
              value={data.location}
              placeholder='Enter location'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='occupation'>Occupation:</label>
            <input
              type='text'
              name="occupation"
              id='occupation'
              value={data.occupation}
              placeholder='Enter occupation'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input
              type='email'
              name="email"
              id='email'
              value={data.email}
              placeholder='Enter email'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input
              type='password'
              name="password"
              id='password'
              value={data.password}
              placeholder='Enter password'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='profile_pic'>Profile Photo:</label>
            <div className='h-14 bg-gray-100 flex justify-center items-center cursor-pointer border hover:border-blue-700' onClick={handleOpenFileUploader}>
              <input
                type='file'
                id='profile_pic'
                className='hidden'
                ref={inputFileRef}
                onChange={handleUploadProfilePic}
                disabled={loading}
              />
              {data.profile_pic ? (
                <p>{data.profile_pic.name}</p>
              ) : (
                <div className='flex items-center gap-3'>
                  <Image
                    src='/assets/icons/upload.svg'
                    width={25}
                    height={25}
                    alt='upload'
                  />
                  <p className='text-sm'>Upload profile image</p>
                </div>
              )}
            </div>
          </div>

          <button
            type="submit"
            className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>

        </form>

        <div className='my-5'>
          <p>Already have an account? <Link href='/login' className='text-blue-700 hover:text-blue-800 hover:underline'>Login</Link></p>
        </div>

      </div>
    </section>
  );
}

export default Register;
\n\n--- File: 8 # src\app\(root)\page.js ---\n'use client'
import ProfileCard from "@/components/ProfileCard";
import UploadPost from "@/components/UploadPost";
import { ContextData } from "@/providers/provider";
import { useContext, useEffect, useState } from "react";
import axios from 'axios'
import PostDisplay from "@/components/PostDisplay";
import Avatar from "@/components/Avatar";
import Divider from "@/components/Divider";
import handleAddRemoveFriends from "@/helpers/handleAddRemoveFriends";
import toast from 'react-hot-toast'
import News from "@/components/News";

export default function Home() {
  const {user, fetchCurrentUserDetails} = useContext(ContextData)
  const [postData,setPostData] = useState([])
  const [friendsList,setFriendsList] = useState([])

  const fetchPost = async()=>{
    const response = await axios.get("/api/post")
    setPostData(response.data.data || [])
  }

  const fetchFriendsList = async()=>{
    const response = await axios.get('/api/friends')
    setFriendsList(response.data.data)
  }

  useEffect(()=>{
    fetchPost()
    fetchFriendsList()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchFriendsList()
    toast(response.message)
  }

  return (
   <div className="container mx-auto p-4 lg:grid grid-cols-[280px,1fr,280px] gap-7 h-full items-start">
        {/*** current user profile*/}
        <section className="bg-white rounded p-2 lg:sticky lg:top-20">
          <ProfileCard
            _id={user?._id}
            profile_pic={user?.profile_pic}
            firstName={user?.firstName || ''}
            lastName={user?.lastName || ''}
            location={user?.location || ''}
            occupation={user?.occupation || ''}
            friends = {user?.friends || []}
          />
          <hr className="m-3"/>
          <h1 className="font-bold mb-3">Your Connections:</h1>
            <div>
              {
                friendsList.map((friend,index)=>{
                  return(
                    <div key={friend?._id}>
                      <div className="flex items-center gap-3 justify-between">
                        <div className="flex items-center gap-3">
                          <Avatar
                            userId={friend._id}
                            width={40}
                            height={40}
                            imageURL={friend?.profile_pic}
                          />
                          <div>
                            <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                            <p className="text-xs">{friend.occupation}</p>
                          </div>
                        </div>
                        <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                      </div>
                      <Divider/>
                    </div>
                  )
                })
              }
            </div>
        </section>


        {/*** upload post and see post*/}
        <section className="rounded mt-5 lg:mt-0">
            <UploadPost
               _id={user?._id}
               profile_pic={user?.profile_pic}
               callApi={fetchPost}
            />

            <div>
                {
                  postData.map((post,index)=>{
                    return(
                      <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                    )
                  })
                }
            </div>

        </section>


         {/*** ads and friend list*/}
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
            <div className="flex flex-row">
            <News/>
            </div>
        </section>
   </div>
  );
}\n\n--- File: 9 # src\app\(root)\find-friends\page.js ---\n'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import { ContextData } from '@/providers/provider'
import toast from 'react-hot-toast'

const FindFriends = () => {
  const [allUser,setAllUser] = useState([])
  const {user, fetchCurrentUserDetails} = useContext(ContextData)

  const fetchAllUser = async()=>{
    const response = await axios.get("/api/all-users")
    const friendList = user?.friends || []
    const removeFriends = response.data.data.filter(userDetails => !friendList.includes(userDetails?._id))
    const removeCurrentUser = removeFriends.filter(userDetails => userDetails?._id !== user?._id) 
    setAllUser(removeCurrentUser)
  }

  useEffect(()=>{
    fetchAllUser()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchAllUser()
    toast(response.message)
  }
  return (
    <div className='container mx-auto p-4'>

        <h3 className='font-semibold text-lg mb-3'>Find <span className='text-orange-500 font-extrabold'>New</span> Friends</h3>
        <div className='flex flex-wrap gap-4'>
          {
              allUser.map((user,index)=>{
                return(
                  <div key={index} className='bg-white p-4 flex justify-center flex-col items-center gap-1 min-w-[180px] min-h-[180px]'>
                      <Avatar
                        userId={user?._id}
                        imageURL={user?.profile_pic}
                        width={60}
                        height={60}
                      />
                      <p className='text-lg font-medium capitalize my-0'>{user.firstName} {user.lastName}</p>
                      <p className='text-xs my-0 -mt-2'>{user.occupation}</p>
                      <button className='bg-blue-800 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm mt-2' onClick={()=>handleAddFriend(user?._id)}>Add Friend</button>
                  </div>
                )
              })
          }
        </div>

    </div>
  )
}

export default FindFriends\n\n--- File: 12 # src\app\(root)\[id]\page.js ---\n'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import { ContextData } from '@/providers/provider'
import PostDisplay from '@/components/PostDisplay'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import Divider from '@/components/Divider'

const UserProfileDetails = ({ params }) => {
    const [data,setData] = useState(null)
    const [friendslist,setFirendsList] = useState([])
    const [postData,setPostData] = useState([])
    const {user, fetchCurrentUserDetails} = useContext(ContextData)
    const [loading,setLoading] = useState(false)
    
    const fetchUserDetails  = async()=>{
      const payload  = {
        userId : params.id
      }
      setLoading(true)
      const response  = await axios.post("/api/user-details",payload)

      setData(response.data.data)
      setFirendsList(response.data.friends)
      setPostData(response.data.post)
      setLoading(false)
    }

    const handleAddFriend = async(friendId)=>{
      const response = await handleAddRemoveFriends(friendId)
      fetchUserDetails()
    }

    useEffect(()=>{
      fetchUserDetails()
    },[])

    const isDisplayAddFriend = user?.friends?.includes(data?._id) || user?._id === data?._id
  return (
    <div className='container mx-auto'>

        <div className='mt-5 grid gap-10 lg:grid-cols-[2fr,1fr] items-start'>
            {/**user information and post */}
            <div className=''>
                {/**user information */}
                <div className='bg-white p-4'>
                      <div className='h-36 bg-slate-200 rounded mb-14'>
                          <div className='bg-white h-36 w-36 rounded-full translate-x-8 translate-y-1/3 p-1 flex justify-center items-center'>
                              <Avatar
                                imageURL={data?.profile_pic}
                                userId={data?._id}
                                width={130}
                                height={130}
                              />
                          </div>
                      </div>
                      <p className='font-bold text-lg lg:text-2xl capitalize'>{data?.firstName} {data?.lastName}</p>
                      <p className='text-base lg:text-lg'>{data?.occupation}</p>

                      {
                        !isDisplayAddFriend && (
                          <button className='bg-blue-800 hover:bg-blue-700 text-white font-semibold px-5 rounded-full my-3 py-2'>Add Friend</button>
                        )
                      }
                </div>

                {/***post */}
                    <div className='w-full'>
                    {
                      postData.map((post,index)=>{
                        return(
                          <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                        )
                      })
                    }
                  </div> 
            </div>
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
              
              <h1 className="font-bold mb-3">Friends List:</h1>
              <div>
                {
                  friendslist.map((friend,index)=>{
                    return(
                      <div key={friend?._id}>
                        <div className="flex items-center gap-3 justify-between">
                          <div className="flex items-center gap-3">
                              <Avatar
                                userId={friend._id}
                                width={40}
                                height={40}
                                imageURL={friend?.profile_pic}
                              />
                              <div>
                                <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                                <p className="text-xs">{friend.occupation}</p>
                              </div>
                          </div>
                          <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                        </div>

                        <Divider/>
                      </div>
                    )
                  })
                }
              </div>
  
          </section>


        </div>


        {
          loading && (
            <div className='fixed top-0 bottom-0 right-0 left-0 bg-slate-500 bg-opacity-25 flex justify-center items-center'>
              <p className='bg-white px-6 py-2 text-lg'>Loading...</p>
            </div>
          )
        }
    </div>
  )
}

export default UserProfileDetails\n\n--- File: 13 # src\app\api\add-remove-friends\route.js ---\nimport connectDB from "@/database/db";
import { getUserDetailsFromToken } from "@/helpers/getUserDetailsFromToken";
import userModel from "@/models/userModel";
import { NextResponse } from 'next/server'

connectDB()
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        const { friendId } = await request.json()

        const currentUserFriendList = user.friends || []
        /**add friends */
        if(!currentUserFriendList.includes(friendId)){
             await userModel.updateOne({ _id : user._id },{
                $push : { friends : friendId }
            })


            await userModel.updateOne({ _id : friendId },{
                $push : { friends : user._id?.toString() }
            })

            return NextResponse.json({
                message : "friend added",
                success : true
            })
        }

        //remove friend 
        await userModel.updateOne({ _id : user._id },{
            $pull : { friends : friendId }
        })


        await userModel.updateOne({ _id : friendId },{
            $pull : { friends : user._id?.toString() }
        })

        return NextResponse.json({
            message : "friend remove",
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 14 # src\app\api\all-users\route.js ---\nimport { NextResponse } from "next/server";
import connectDB from "@/database/db";
import userModel from "@/models/userModel";

connectDB()
export async function GET(){
   try {
        const users = await userModel.find()

        const usersDetailsList = users.map(user =>{
            return {
                _id : user._id,
                firstName : user.firstName,
                lastName : user.lastName,
                occupation : user.occupation,
                profile_pic : user.profile_pic
            }
        })

        return NextResponse.json({
            message : "all users",
            data : usersDetailsList,
            success : true
        })
   } catch (error) {
     return NextResponse.json({
        message : error.message || error,
        error : true
     })
   } 
}\n\n--- File: 15 # src\app\api\current-user\route.js ---\nimport { getUserDetailsFromToken } from "@/helpers/getUserDetailsFromToken";
import { NextResponse } from "next/server";
import connectDB from "@/database/db";

connectDB()
export async function GET(request){
    try {
        const user =  await getUserDetailsFromToken(request)
        
        return NextResponse.json({
            message : "Current user Details",
            data : user
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 16 # src\app\api\friends\route.js ---\nimport { NextResponse } from 'next/server'
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import userModel from '@/models/userModel'


connectDB()
export async function GET(request){
    try {
        const user = await getUserDetailsFromToken(request)

        const friendListId = user.friends || []

        const friendslist = await userModel.find({
            _id : { $in : friendListId }
        })

        const friends =  friendslist.map((userData)=>{
            return{
                _id : userData._id,
                firstName : userData.firstName,
                lastName : userData.lastName,
                occupation : userData.occupation,
                profile_pic : userData.profile_pic
            }
        })

        return NextResponse.json({
            message : 'friend list',
            data :friends,
            success :true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 17 # src\app\api\login\route.js ---\nimport userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import jwt from 'jsonwebtoken'
import connectDB from '@/database/db'

connectDB() 

export async function POST(request){
    try {
        const { email , password } = await request.json()

        const user = await userModel.findOne({ email })

        if(!user){
            return NextResponse.json({message : "user not exit!"},{status : 400})
        }

        const checkPassword = await bcryptjs.compare(password,user.password)

        if(!checkPassword){
            return NextResponse.json({ message : "Check your password"})
        }

        const tokenData = {
            id : user._id,
            email : user.email
        }

        const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})

        const response =  NextResponse.json({
            token : token,
            message : "Login successfully",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set("token",token,cookiesOption)
        
        return response
 
    } catch (error) {
       return NextResponse.json({ message : error.message || error })
    }
}\n\n--- File: 18 # src\app\api\logout\route.js ---\nimport { NextResponse } from 'next/server'

export async function GET(){
    try {
        const response = NextResponse.json({
            message : "Logout successfull",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set('token','',cookiesOption)

        return response
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 19 # src\app\api\post\route.js ---\nimport connectDB from '@/database/db'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()
export async function GET(){
    try {
        const post = await postModel.find().populate('userId').sort({ createdAt : -1})

        return NextResponse.json({
            data : post,
            message : "post",
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 20 # src\app\api\post\comment\route.js ---\nimport connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()


/***save commment */
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const { description , postId } = await request.json()

        const payload  = {
            description :  description,
            userId : user._id
        }

        const commentPost = await postModel.updateOne({ _id : postId},{
            $push : { comment : payload }
        })

        const commentList = await postModel.find({ _id : postId}).populate({
            path : 'comment',
            populate : {
                path : 'userId'
            }
        })

        return NextResponse.json({
            message : "Comment",
            data : commentList,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 21 # src\app\api\post\get-comment-for-post\route.js ---\nimport connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()


/***save commment */
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const {  postId } = await request.json()

        const commentList = await postModel.findOne({ _id : postId }).populate({
            path : 'comment',
            populate : {
                path : 'userId'
            }
        })

        return NextResponse.json({
            message : "Comment",
            data : commentList,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 22 # src\app\api\post\like\route.js ---\nimport connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        const { _id } = await request.json()

        const post = await postModel.findOne({ _id : _id })

        /*checkin user id is availabe in like array*/
        if(post.like.includes(user.id)){
            const updatePost = await postModel.updateOne({ _id : _id },{
               $pull : { like : user._id}
            })

            const postData = await postModel.findOne({ _id : _id })
            return NextResponse.json({
                message : "Like",
                data : postData.like,
                success : true
            })
        }

        const updataPost = await postModel.updateOne({ _id : _id },{
            $push : { like : user._id}
         })

        const postData = await postModel.findOne({ _id : _id })

        return NextResponse.json({
            message : 'Liked',
            data : postData.like,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}\n\n--- File: 23 # src\app\api\register\route.js ---\nimport userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import uploadImage from '@/helpers/uploadImage'
import connectDB from '@/database/db'

connectDB()

export async function POST(request){
    try {
        const formData = await request.formData()
        const firstName = formData.get('firstName')
        const lastName = formData.get('lastName')
        const location = formData.get('location')
        const occupation = formData.get('occupation')
        const email  = formData.get('email')
        const password = formData.get('password')
        const profilePic = formData.get('profile_pic')

        //checking email id
        const checkEmailid = await userModel.findOne({ email })
        if(checkEmailid){
            return NextResponse.json({ message  : "Already exits user"})
        }

        //password into hash format
        const salt = await bcryptjs.genSalt(10)
        const hashPassword = await bcryptjs.hash(password , salt)

        //upload profile pic in cloudinary
        let uploadProfilePic = ''
        if(profilePic?.name){
            uploadProfilePic = await uploadImage(profilePic)
        } 
        
        const payload = {
            firstName,
            lastName,
            location,
            occupation,
            email,
            password : hashPassword,
            profile_pic : uploadProfilePic.url,
            profileViews : Math.floor(Math.random() * 1000),  
            profileImpressions : Math.floor(Math.random() * 1000),
        }

        const user  = new userModel(payload)
        const saveUserData = await user.save()

        return NextResponse.json({message : "User created successfully", data : saveUserData, success : true })

    } catch (error) {
        return NextResponse.json({ message : error.message || error })
    }
}\n\n--- File: 24 # src\app\api\upload-post\route.js ---\nimport connectDB from '@/database/db'
import { NextResponse } from 'next/server'
import postModel from '@/models/postModel'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import uploadImage from '@/helpers/uploadImage'


connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const formdata = await request.formData()
        const description = formdata.get("description")
        const image = formdata.get("image")

        let postUpload = ''
        if(image){
            postUpload = await uploadImage(image)
        } 

        const payload =  {
            image : postUpload.url,
            description : description,
            userId : user._id
        }

        const post = new postModel(payload)
        const savePost = await post.save()

        return NextResponse.json({
            message : "Upload successfully",
            success : true,
            data : savePost
        })

    } catch (error) {
        return NextResponse.json({ message : error.message || message })
    }   
}\n\n--- File: 25 # src\app\api\user-details\route.js ---\nimport { NextResponse } from 'next/server'
import connectDB from '@/database/db'
import userModel from '@/models/userModel'
import postModel from '@/models/postModel'

connectDB()

export async function POST(request){
    try {
        const { userId } = await request.json()

        //user
        const user   = await userModel.findOne({ _id : userId})


        //friends
        const friendListId = user.friends || []
        const friendslist = await userModel.find({
            _id : { $in : friendListId }
        })
        const friends =  friendslist.map((userData)=>{
            return{
                _id : userData._id,
                firstName : userData.firstName,
                lastName : userData.lastName,
                occupation : userData.occupation,
                profile_pic : userData.profile_pic
            }
        })

        //post
        const post = await postModel.find({ userId : userId }).populate('userId').sort({ createdAt : -1})

        return NextResponse.json({
            data : user,
            friends : friends,
            post : post,
            message : 'user details',
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}\n\n--- File: 26 # src\components\Avatar.js ---\nimport React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar\n\n--- File: 28 # src\components\Header.js ---\n'use client'
import React, { useContext, useState } from 'react'
import Image from 'next/image'
import { headerNavLink } from '@/constants'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import axios from 'axios'
import toast from 'react-hot-toast'
import { useRouter } from 'next/navigation'
import { ContextData } from '@/providers/provider'
import Avatar from './Avatar'
import { Search } from 'lucide-react'

const Header = () => {
    const path = usePathname()
    const router = useRouter()
    const [openUserMenu, setOpenUserMenu] = useState(false)
    const { user, fetchCurrentUserDetails } = useContext(ContextData)

    const handleOpenClose = () => {
        setOpenUserMenu((prev) => !prev)
    }

    const handleUserLogout = async () => {
        const response = await axios.get('/api/logout')
        setOpenUserMenu(false)
        toast(response?.data.message)
        router.push("/login")
    }

    return (
        <header className='h-16 bg-white sticky z-40 shadow top-0'>
            <div className='container mx-auto h-full flex items-center px-4 justify-between'>
                <div className='grid grid-cols-[170px,1fr] items-center'>
                    <Link href={"/"}>
                        <Image 
                            src={'/logo.png'}
                            width={190}
                            height={70}
                            alt='logo'
                        />
                    </Link>

                    {/* Search input */}
                    <div className='w-full items-center gap-2 border bg-slate-100 px-1 rounded hidden lg:flex'>
                        <input 
                            type='text' 
                            placeholder='Search here...'
                            className='w-full max-w-52 bg-slate-100 py-1 px-2 outline-none'
                        />
                        <Search />
                    </div>
                </div>

                <div className='flex items-center gap-10 h-full'>
                    {/* Navbar */}
                    <nav className='hidden lg:flex items-center gap-4 h-full'>
                        {headerNavLink.map((navlink, index) => { 
                            const isActive = path === navlink.route
                            const Icon = navlink.icon
                            return (
                                <Link 
                                    href={navlink.route}
                                    key={index}
                                    className={`flex flex-col justify-center items-center gap-1 h-full px-4 ${isActive ? 'bg-slate-100' : ''}`}
                                >
                                    <Icon />
                                    <p className='text-sm'>{navlink.label}</p>
                                </Link>
                            )
                        })}
                    </nav>

                    <div>
                        {/* Current user login image */}
                        <div className='flex flex-col justify-center items-center cursor-pointer relative'>
                            <div onClick={handleOpenClose} className='flex flex-col justify-center items-center'>
                                <Avatar
                                    userId={user?._id}
                                    imageURL={user?.profile_pic}
                                    width={28}
                                    height={28}
                                    disable={true}
                                />
                                <p className='text-sm'>Me</p>
                            </div>
                            
                            {/* User menu */}
                            {openUserMenu && (
                                <div className='shadow absolute top-14 right-0 min-w-60 p-4 rounded bg-white'>
                                    <div className='font-semibold text-center flex flex-col justify-center items-center'>
                                        <Avatar
                                            userId={user?._id}
                                            imageURL={user?.profile_pic}
                                            width={45}
                                            height={45}
                                            extraWidth={20}
                                            extraHeight={20}
                                        />
                                        <p className='text-lg'>
                                            { user?.firstName + " " + user?.lastName }
                                        </p>
                                        <p className='text-sm'>
                                            {user?.occupation}
                                        </p>
                                    </div>

                                    <div className='p-[0.5px] my-1 bg-slate-200'></div>

                                    {/* Mobile responsive */}
                                    <nav className='flex lg:hidden justify-center flex-col gap-2 h-full'>
                                        {headerNavLink.map((navlink, index) => { 
                                            const isActive = path === navlink.route
                                            const Icon = navlink.icon
                                            return (
                                                <Link 
                                                    href={navlink.route}
                                                    key={index}
                                                    className={`flex flex-row gap-2 h-full px-4 py-3 ${isActive ? 'bg-slate-100' : ''}`}
                                                    onClick={handleOpenClose}
                                                >
                                                    <Icon />
                                                    <p className='text-sm'>{navlink.label}</p>
                                                </Link>
                                            )
                                        })}
                                    </nav>

                                    <button className='bg-red-600 text-white rounded hover:bg-red-700 w-full py-1' onClick={handleUserLogout}>Logout</button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        </header>
    )
}

export default Header
\n\n--- File: 30 # src\components\PostDisplay.js ---\nimport React, { useContext, useEffect, useState } from 'react'
import Avatar from './Avatar'
import Image from 'next/image'
import { ContextData } from '@/providers/provider'
import axios from 'axios'
import { MessageSquare, Share, UserPlus } from 'lucide-react'

const PostDisplay = ({ data ,handleAddFriend }) => {
    const [likeData,setLikeData] = useState(data?.like || [])
    const [commentData,setCommentData] = useState(data?.comment || [])
    const [openComment,setOpenComment] = useState(false)
    const [comment,setComment] = useState('')

    const {user, fetchCurrentUserDetails} = useContext(ContextData)


    const handleLikePost = async()=>{
        const payload = {
            _id : data?._id
        }
        const response = await axios.post('/api/post/like',payload)

        setLikeData(response.data.data)
    }


    const handleOpenCloseComment = () =>{
        setOpenComment(preve => !preve)
    }

    const fetchCommentData = async() =>{
        const payload  = {
            postId : data?._id
        }
        const response = await axios.post("api/post/get-comment-for-post",payload)

        setCommentData(response.data.data.comment || [])
    }

    useEffect(()=>{
        if(openComment){
            fetchCommentData()
        }
    },[])


    const handleuploadComment = async() =>{
        const payload = {
            description : comment,
            postId : data?._id
        }
        if(comment){
            const response  = await axios.post("api/post/comment",payload)
            setComment('')
            fetchCommentData()
        }
        
    }
    


    const currentUserLiked = likeData.includes(user?._id)
    const isDisplayAddFriend = user?.friends?.includes(data?.userId?._id) || user?._id === data?.userId?._id
  return (
    <div className='bg-white p-4 my-6'>
        <div className='flex gap-3 items-center justify-between'>
            <div className='flex gap-3 items-center'>
                <Avatar
                    userId={data.userId._id}
                    imageURL={data.userId.profile_pic}
                    width={40}
                    height={40}
                />
                <div>
                    <p className='font-bold'>{data.userId.firstName} {data.userId.lastName}</p>
                    <p className='text-xs'>{data.userId.occupation}</p>
                </div>
            </div>

            {
                !isDisplayAddFriend && (
                    <div className='bg-white shadow-md p-2 rounded-full flex justify-center items-center cursor-pointer hover:bg-blue-700' onClick={()=>handleAddFriend(data?.userId?._id)}>
                        <UserPlus/>
                    </div>
                )
            }
           
        </div>

        <p className='py-3'>
            {data.description}
        </p>

        <div className='w-full h-full'>
            {
                data.image && (
                    <Image 
                        src={data.image}
                        width={1000}
                        height={1000}
                        alt='post'
                    />
                )
            }
        </div>


        <div className='text-sm flex items-center justify-between mt-3'>
             {/**like count */}
            <div>
                {likeData.length  === 0 ? "You're first to like" : likeData.length + " Likes"  }
            </div>

            {/**comment count */}
            <div>
                {commentData.length} comment
            </div>

        </div>

        <div className='p-[0.5px] bg-slate-200'></div>

        
        <div className='py-1 flex justify-between gap-3'>
             {/**like */}
             <div className='flex items-center gap-1 cursor-pointer' onClick={handleLikePost}>
                {
                    currentUserLiked ? (
                        <Image
                            src={'/liked.svg'}
                            width={20}
                            height={20}
                            alt='like' 
                        />
                    ) : (
                        <Image
                        src={'/like.svg'}
                        width={20}
                        height={20}
                        alt='like' 
                        />
                    )
                }
                
                <p  className={currentUserLiked && 'text-blue-800 font-semibold'}>Like</p>
             </div>


              {/**comment */}
              <div className='flex items-center gap-1 cursor-pointer hover:text-blue-700' onClick={handleOpenCloseComment}>
                    <MessageSquare/>
                    <p>Comment</p>  
              </div>


            {/**share */}
            <div>
                <div className='flex items-center gap-1 cursor-pointer'>
                <Share/>
                <p>Share</p> 
                </div>
            </div>
        </div>


        {/****display all the comment */}
        {
            openComment && (
                <div className='p-4 bg-white w-full'>
                     <div className='flex items-center gap-4 w-full'>
                        <Avatar
                            userId={user._id}
                            imageURL={user.profile_pic}
                            width={40}
                            height={40}
                            alt={user.firstName}
                        />
                        <div className='w-full flex gap-1'>
                            <input 
                                type='text' 
                                placeholder='type comment here...' 
                                className='bg-slate-100 rounded-full px-4 py-2 w-full outline-none' 
                                onChange={(e)=>setComment(e.target.value)}
                                value={comment}
                            />
                            <button className='bg-blue-700 text-white text-sm px-3 py-1 rounded-full' onClick={handleuploadComment}>Send</button>
                        </div>
                    </div>


                    {/**list of comment */}
                    <div className='mt-3'>
                        {
                            commentData.map((comment,index)=>{
                                return(
                                    <div className='ml-5 p-2 border-b' key={comment?._id}>
                                        <div className='flex gap-3 items-center'>
                                            <Avatar
                                                userId={comment?.userId?._id}
                                                imageURL={comment?.userId?.profile_pic}
                                                width={30}
                                                height={30}
                                                alt={comment?.userId?.firstName}
                                            />
                                            <div className='flex flex-col'>
                                                <p className='font-semibold text-sm'>{comment?.userId?.firstName} {comment?.userId?.lastName}</p>
                                                <p className='text-xs -mt-1'>{comment?.userId?.occupation}</p>
                                            </div>
                                        </div> 
                                        <div className='text-sm py-1 px-2'>
                                            {comment.description}
                                        </div>   
                                    </div>
                                )
                            })
                        }
                    </div>

                    
                </div>
            )
        }
    </div>
  )
}

export default PostDisplay\n\n--- File: 31 # src\components\ProfileCard.js ---\n'use client'
import React from 'react'
import Avatar from './Avatar'
import { LucideUserPlus, MapPinIcon } from 'lucide-react'

const ProfileCard = ({_id, firstName, lastName, occupation, location, profile_pic, friends = [], profileViews = 0 , profileImpressions = 0  }) => {
  return (
    <div className='p-2'>
      {/**image  */}
        <div className='bg-slate-200 h-16 mb-10'>
            <div className='w-16 h-16 rounded-full bg-white mx-auto translate-y-8 shadow-md'>
                <Avatar
                    userId={_id}
                    imageURL={profile_pic}
                    width={64}
                    height={64}
                />
            </div>
        </div>

        {/**name and occupation */}
        <div className='text-center'>
            <p className='font-bold text-lg'>{firstName +" "+lastName}</p> 
            <p className='text-sm'>{occupation}</p>
        </div>

        <div className='p-[0.5px] bg-slate-200 my-2'></div>

          {/**name and friends */}
         <div className='grid gap-1'>
              <div className='flex items-center gap-3'>
                <MapPinIcon/>
                <p>{location}</p>
              </div>
              <div  className='flex items-center gap-3'>
                <LucideUserPlus/>
                <p >Friends <span className='text-xs'>({friends.length})</span></p>
              </div>
         </div>


         <div className='p-[0.5px] bg-slate-200 my-2'></div>

        {/****profile views and profile impresss */}
        <div className='grid gap-1'>
            <div className='flex justify-between items-center gap-3'>
                <p>Profile views</p>
                <p>{profileViews}</p>
            </div>

            <div className='flex justify-between items-center gap-3'>
                <p>Profile impressions</p>
                <p>{profileImpressions}</p>
            </div>

        </div>

     
    </div>
  )
}

export default ProfileCard\n\n--- File: 32 # src\components\UploadPost.js ---\n'use client'
import React, { useRef, useState } from 'react'
import Avatar from './Avatar'
import Divider from './Divider'
import toast from 'react-hot-toast'
import axios from 'axios'
import { CrossIcon, ImageIcon } from 'lucide-react'

const UploadPost = ({ _id, profile_pic,callApi }) => {
    const [data, setData] = useState({
        description: "",
        image: ""
    })
    const inputFileRef = useRef()
    const [loading,setLoading] = useState(false)

    const handleOpenFileExplore = () =>{
        inputFileRef.current.click()
    }

    const handleOnChange = (e) => {
        const { value, name } = e.target

        setData((preve) => {
            return {
                ...preve,
                [name]: value
            }
        })
    }

    const handleUploadFile = (e)=>{
        const file = e.target.files[0]

        setData((preve)=>{
            return{
                ...preve,
                image : file
            }
        })
    }
    const handleClearUpload = (e)=>{
        setData((preve)=>{
            return{
                ...preve,
                image : ""
            }
        })
    }

    const handlePost = async(e)=>{
        e.preventDefault()

        if(!data.description){
            toast("Please type something....")
            return
        }

        const formData = new FormData()
        formData.set("description",data.description)
        formData.set("image",data.image)
        setLoading(true)
        const response = await axios.post('/api/upload-post',formData)
        setLoading(false)
        toast(response.data.message)
        if(response.data.success){
            setData({
                description: "",
                image: ""
            })
            callApi()
        }


    }

    return (
        <div className='bg-white p-4 rounded'>
            <div className='flex gap-4 items-start'>
                <Avatar
                    imageURL={profile_pic}
                    width={50}
                    height={50}
                    userId={_id}
                />

                <div className='w-full'>
                    <textarea
                        name='description'
                        placeholder='type here...'
                        className='bg-slate-100 px-4 py-2 w-full outline-none rounded resize-none'
                        value={data.description}
                        onChange={handleOnChange}
                    />
                    {
                        data?.image && (
                            <div className='bg-slate-100 border text-center relative py-2 px-4'>
                                <div className='w-5 h-5 text-sm hover:text-red-600 cursor-pointer rounded-full absolute right-0 top-0' onClick={handleClearUpload}>
                                    <CrossIcon/>
                                </div>
                                {data?.image?.name}
                            </div>
                        )
                    }
                    
                </div>
            </div>



            <Divider />

            <div className='flex justify-between items-center'>
                <div className='flex items-center gap-2 cursor-pointer' onClick={handleOpenFileExplore}>
                    <ImageIcon/>
                    <p className='hover:text-blue-700'>Image</p>

                    <input type='file' className='hidden' ref={inputFileRef} onChange={handleUploadFile}/>
                </div>

                <button className='bg-blue-700 px-5 py-1 text-white rounded-full' onClick={handlePost}>Post</button>
            </div>



            {/***loading state */}
            {
                loading && (
                <div className='fixed bg-slate-200 bg-opacity-60 top-0 right-0 left-0 bottom-0 w-full h-full flex justify-center items-center'>
                    <p className='bg-white p-4'>Loading....</p>
                </div>
                )
            }
            
        </div>
    )
}

export default UploadPost\n\n--- File: 34 # src\database\db.js ---\nimport mongoose from "mongoose";

async function connectDb(){
    try {
        await mongoose.connect(process.env.MONGO_URI)
        const dbConnection = mongoose.connection
        dbConnection.on('db connected',()=>{
            console.log("connect to mongoDB")
        })
        dbConnection.on('error',(error)=>{
            console.log("connection failed "+error)
        })
    } catch (error) {
        console.log("Error in Database",error)
    }
}

export default connectDb\n\n--- File: 36 # src\helpers\handleAddRemoveFriends.js ---\nimport axios from 'axios'

const handleAddRemoveFriends = async(friendId) =>{
    const payload = {
        friendId : friendId
    }
    const response = await axios.post('/api/add-remove-friends',payload)

    return response.data
}

export default handleAddRemoveFriends\n\n--- File: 37 # src\helpers\uploadImage.js ---\nimport {v2 as cloudinary} from 'cloudinary';
          
cloudinary.config({ 
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME, 
  api_key: process.env.CLOUDINARY_API_KEY, 
  api_secret: process.env.CLOUDINARY_API_SECRET
});


const uploadImage = async(file)=>{
    const buffer = Buffer.from(await file.arrayBuffer())

    const uploadFileData = await new Promise((resolve,reject)=>{
        cloudinary.uploader.upload_stream({ folder : 'linkedIn_clone'},(error,uploadResult)=>{
            return resolve(uploadResult)
        }).end(buffer)
    })

    return uploadFileData
}

export default uploadImage\n\n--- File: 38 # src\models\postModel.js ---\nimport mongoose , { Schema } from 'mongoose'

const commentSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    }
},{
    timestamps : true
})


const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    image : {
        type : String,
        default : ""
    },
    userId : {
        type : Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    },
    comment : [commentSchema]
},{
    timestamps : true
})


const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel\n\n--- File: 39 # src\models\userModel.js ---\nimport mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        min : 3,
        max : 100,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        min : 3,
        max : 100,
        required : [true, "Provide last name"]
   },
   location : {
        type : String,
        default : ""
   },
   occupation : {
        type : String,
        default : ""
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   },
   profile_pic : {
        type : String,
        default : ""
   },
   profileViews : {
        type : Number,
        min : 0,
        default : 0
   },
   profileImpressions : {
        type : Number,
        min : 0,
        default : 0
   },
   friends : {
     type : Array,
     default : []
   }
},{
    timeStamps : true
})


const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)


export default userModel\n\n--- File: 40 # src\providers\provider.js ---\n'use client'

import axios from "axios";
import { createContext, useEffect, useState } from "react";

export const ContextData = createContext(null)

export const Provider = ({children}) =>{
    const [user,setData] = useState(null)

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return(
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    )
}

Please provide:
1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.
2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:
    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)
    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)
    - `label`: A brief label for the interaction **in just a few words** (e.g., "Manages", "Inherits", "Uses").
    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.
    Simplify the relationship and exclude those non-important ones.

IMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.

Format the output as YAML:

```yaml
summary: |
  A brief, simple explanation of the project.
  Can span multiple lines with **bold** and *italic* for emphasis.
relationships:
  - from_abstraction: 0 # AbstractionName1
    to_abstraction: 1 # AbstractionName2
    label: "Manages"
  - from_abstraction: 2 # AbstractionName3
    to_abstraction: 0 # AbstractionName1
    label: "Provides config"
  # ... other relationships
```

Now, provide the YAML output:

2025-05-30 19:09:12,329 - INFO - RESPONSE (from cache): ```yaml
summary: |
  This project is a **social media** platform, similar to *LinkedIn*. It allows users to **register and login**, create and share **posts**, connect with **friends**, and manage their profiles. The platform provides a space for users to network and share professional updates.
relationships:
  - from_abstraction: 2 # API Route Handlers
    to_abstraction: 0 # User Authentication and Authorization
    label: "Handles auth requests"
  - from_abstraction: 0 # User Authentication and Authorization
    to_abstraction: 1 # User Data Model
    label: "Authenticates users"
  - from_abstraction: 2 # API Route Handlers
    to_abstraction: 1 # User Data Model
    label: "Handles user data"
  - from_abstraction: 2 # API Route Handlers
    to_abstraction: 3 # Post Data Model
    label: "Handles post data"
  - from_abstraction: 5 # Avatar Component
    to_abstraction: 1 # User Data Model
    label: "Displays user data"
  - from_abstraction: 2 # API Route Handlers
    to_abstraction: 6 # Database Connection
    label: "Uses database"
  - from_abstraction: 7 # Handle Add Remove Friends Helper
    to_abstraction: 2 # API Route Handlers
    label: "Calls API endpoints"
  - from_abstraction: 4 # Context Provider (ContextData)
    to_abstraction: 1 # User Data Model
    label: "Provides user data"
  - from_abstraction: 2 # API Route Handlers
    to_abstraction: 8 # Image Upload Helper
    label: "Uses for uploads"
  - from_abstraction: 3 # Post Data Model
    to_abstraction: 1 # User Data Model
    label: "References user data"
  - from_abstraction: 0 # User Authentication and Authorization
    to_abstraction: 4 # Context Provider (ContextData)
    label: "Relies on user context"
```
2025-05-30 19:09:12,335 - INFO - PROMPT: 
Given the following project abstractions and their relationships for the project ```` LinkedIn ````:

Abstractions (Index # Name):
- 0 # User Authentication and Authorization
- 1 # User Data Model
- 2 # API Route Handlers
- 3 # Post Data Model
- 4 # Context Provider (ContextData)
- 5 # Avatar Component
- 6 # Database Connection
- 7 # Handle Add Remove Friends Helper
- 8 # Image Upload Helper

Context about relationships and project summary:
Project Summary:
This project is a **social media** platform, similar to *LinkedIn*. It allows users to **register and login**, create and share **posts**, connect with **friends**, and manage their profiles. The platform provides a space for users to network and share professional updates.


Relationships (Indices refer to abstractions above):
- From 2 (API Route Handlers) to 0 (User Authentication and Authorization): Handles auth requests
- From 0 (User Authentication and Authorization) to 1 (User Data Model): Authenticates users
- From 2 (API Route Handlers) to 1 (User Data Model): Handles user data
- From 2 (API Route Handlers) to 3 (Post Data Model): Handles post data
- From 5 (Avatar Component) to 1 (User Data Model): Displays user data
- From 2 (API Route Handlers) to 6 (Database Connection): Uses database
- From 7 (Handle Add Remove Friends Helper) to 2 (API Route Handlers): Calls API endpoints
- From 4 (Context Provider (ContextData)) to 1 (User Data Model): Provides user data
- From 2 (API Route Handlers) to 8 (Image Upload Helper): Uses for uploads
- From 3 (Post Data Model) to 1 (User Data Model): References user data
- From 0 (User Authentication and Authorization) to 4 (Context Provider (ContextData)): Relies on user context


If you are going to make a tutorial for ```` LinkedIn ````, what is the best order to explain these abstractions, from first to last?
Ideally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.

Output the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.

```yaml
- 2 # FoundationalConcept
- 0 # CoreClassA
- 1 # CoreClassB (uses CoreClassA)
- ...
```

Now, provide the YAML output:

2025-05-30 19:09:12,393 - INFO - RESPONSE (from cache): ```yaml
- 0 # User Authentication and Authorization
- 1 # User Data Model
- 2 # API Route Handlers
- 3 # Post Data Model
- 4 # Context Provider (ContextData)
- 5 # Avatar Component
- 6 # Database Connection
- 7 # Handle Add Remove Friends Helper
- 8 # Image Upload Helper
```
2025-05-30 19:09:12,396 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "User Authentication and Authorization". This is Chapter 1.

Concept Details:
- Name: User Authentication and Authorization
- Description:
This abstraction manages user login, registration, and access control. Think of it as the bouncer at a club, verifying IDs (credentials) and deciding who gets in and where they're allowed to go based on roles. It ensures that only authenticated users can access certain parts of the application. The `middleware` checks for existing authentication tokens to redirect users appropriately.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
This is the first chapter.

Relevant Code Snippets (Code itself remains unchanged):
--- File: src\middleware.js ---
import { NextResponse } from 'next/server'
 
// This function can be marked `async` if using `await` inside
export function middleware(request) {
    const path = request.nextUrl.pathname

    const isPublicPath = path === '/login' || path === '/register'

    const token = request.cookies.get('token')?.value || ''

    if(isPublicPath && token){
        return NextResponse.redirect(new URL('/',request.nextUrl))
    }

    if(!isPublicPath && !token){
        return NextResponse.redirect(new URL('/login',request.nextUrl))
    }

}
 


// See "Matching Paths" below to learn more
export const config = {
  matcher: [    
    '/login',
    '/register',
    '/'
  ],
}

--- File: src\app\(auth)\login\page.js ---
'use client'

import React, {  useState } from 'react'
import Link from 'next/link'
import axios from 'axios'
import toast from 'react-hot-toast';
import { useRouter } from 'next/navigation'

const Login = () => {
  const [data,setData] = useState({
    email : "",
    password : "",
  })
  const [loading,setLoading] = useState(false)
  const router = useRouter()

  const handleOnChange =  (e) =>{
    const {name , value } = e.target

    setData((preve)=>{
      return{
          ...preve,
           [name] : value
      }
    })
  }

  const handleSubmit = async(e) =>{
    e.preventDefault()

    const response = await axios.post('/api/login',data)
    toast(response.data.message)


    if(response.data.success){
      setData({
        email : "",
        password : "",
      })
      router.push("/")
    }
    
  }


  return (
    <section className='container w-full mx-auto p-1 mt-5'>
    <div className='w-full max-w-md bg-white shadow border p-4 mx-auto'>
        <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
          
          <div className='flex flex-col gap-1'>
                <label htmlFor='email'>Email:</label>
                <input
                  type='email'
                  name="email"
                  id='email'
                  value={data.email}
                  placeholder='enter email'
                  onChange={handleOnChange}
                  disabled={loading}
                  className='bg-slate-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
                />
          </div>


          <div className='flex flex-col gap-1'>
                <label htmlFor='password'>Password:</label>
                <input
                  type='password'
                  name="password"
                  id='password'
                  value={data.password}
                  placeholder='enter password'
                  onChange={handleOnChange}
                  disabled={loading}
                  className='bg-slate-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
                />
          </div>

          <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
        </form>

        <div className='my-5'>
          <p>Create new account ? <Link href={'/register'} className='text-blue-700 hover:text-blue-800 hover:underline'>Register</Link></p>
        </div>
    </div>
</section>
  )
}

export default Login

--- File: src\app\(auth)\register\page.js ---
'use client'

import React, { useRef, useState } from 'react'
import Image from 'next/image'
import Link from 'next/link'
import axios from 'axios'
import toast from 'react-hot-toast';
import { useRouter } from 'next/navigation'

const Register = () => {
  const [data, setData] = useState({
    firstName: "",
    lastName: "",
    location: "",
    occupation: "",
    email: "",
    password: "",
    profile_pic: null,
  });
  const [loading, setLoading] = useState(false);
  const inputFileRef = useRef();
  const router = useRouter();

  const handleOnChange = (e) => {
    const { name, value } = e.target;
    setData(prev => ({
      ...prev,
      [name]: value
    }));
  }

  const handleOpenFileUploader = () => {
    inputFileRef.current.click();
  }

  const handleUploadProfilePic = (e) => {
    const file = e.target.files[0];
    setData(prev => ({
      ...prev,
      profile_pic: file
    }));
  }

  const handleSubmit = async (e) => {
    e.preventDefault();

    const formData = new FormData();
    formData.append("firstName", data.firstName);
    formData.append("lastName", data.lastName);
    formData.append("location", data.location);
    formData.append("occupation", data.occupation);
    formData.append("email", data.email);
    formData.append("password", data.password);
    if (data.profile_pic) {
      formData.append("profile_pic", data.profile_pic);
    }

    try {
      setLoading(true);
      const response = await axios.post('/api/register', formData);
      toast.success(response.data.message);

      if (response.data.success) {
        setData({
          firstName: "",
          lastName: "",
          location: "",
          occupation: "",
          email: "",
          password: "",
          profile_pic: null,
        });
        router.push("/login");
      }
    } catch (error) {
      toast.error("Registration failed. Please try again.");
    } finally {
      setLoading(false);
    }
  }

  return (
    <section className='container w-full mx-auto p-4 mt-5'>
      <div className='w-full max-w-md bg-white shadow border p-4 mx-auto'>

        <form className='grid gap-4' onSubmit={handleSubmit}>

          <div className='grid lg:grid-cols-2 gap-4'>
            <div className='flex flex-col gap-1'>
              <label htmlFor='firstName'>First Name:</label>
              <input
                type='text'
                name="firstName"
                id='firstName'
                value={data.firstName}
                placeholder='Enter first name'
                onChange={handleOnChange}
                disabled={loading}
                className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
              />
            </div>
            <div className='flex flex-col gap-1'>
              <label htmlFor='lastName'>Last Name:</label>
              <input
                type='text'
                name="lastName"
                id='lastName'
                value={data.lastName}
                placeholder='Enter last name'
                onChange={handleOnChange}
                disabled={loading}
                className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
              />
            </div>
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='location'>Location:</label>
            <input
              type='text'
              name="location"
              id='location'
              value={data.location}
              placeholder='Enter location'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='occupation'>Occupation:</label>
            <input
              type='text'
              name="occupation"
              id='occupation'
              value={data.occupation}
              placeholder='Enter occupation'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input
              type='email'
              name="email"
              id='email'
              value={data.email}
              placeholder='Enter email'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input
              type='password'
              name="password"
              id='password'
              value={data.password}
              placeholder='Enter password'
              onChange={handleOnChange}
              disabled={loading}
              className='bg-gray-100 w-full py-2 px-2 focus:outline-blue-700 rounded'
            />
          </div>

          <div className='flex flex-col gap-1'>
            <label htmlFor='profile_pic'>Profile Photo:</label>
            <div className='h-14 bg-gray-100 flex justify-center items-center cursor-pointer border hover:border-blue-700' onClick={handleOpenFileUploader}>
              <input
                type='file'
                id='profile_pic'
                className='hidden'
                ref={inputFileRef}
                onChange={handleUploadProfilePic}
                disabled={loading}
              />
              {data.profile_pic ? (
                <p>{data.profile_pic.name}</p>
              ) : (
                <div className='flex items-center gap-3'>
                  <Image
                    src='/assets/icons/upload.svg'
                    width={25}
                    height={25}
                    alt='upload'
                  />
                  <p className='text-sm'>Upload profile image</p>
                </div>
              )}
            </div>
          </div>

          <button
            type="submit"
            className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>

        </form>

        <div className='my-5'>
          <p>Already have an account? <Link href='/login' className='text-blue-700 hover:text-blue-800 hover:underline'>Login</Link></p>
        </div>

      </div>
    </section>
  );
}

export default Register;


--- File: src\app\api\login\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import jwt from 'jsonwebtoken'
import connectDB from '@/database/db'

connectDB() 

export async function POST(request){
    try {
        const { email , password } = await request.json()

        const user = await userModel.findOne({ email })

        if(!user){
            return NextResponse.json({message : "user not exit!"},{status : 400})
        }

        const checkPassword = await bcryptjs.compare(password,user.password)

        if(!checkPassword){
            return NextResponse.json({ message : "Check your password"})
        }

        const tokenData = {
            id : user._id,
            email : user.email
        }

        const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})

        const response =  NextResponse.json({
            token : token,
            message : "Login successfully",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set("token",token,cookiesOption)
        
        return response
 
    } catch (error) {
       return NextResponse.json({ message : error.message || error })
    }
}

--- File: src\app\api\logout\route.js ---
import { NextResponse } from 'next/server'

export async function GET(){
    try {
        const response = NextResponse.json({
            message : "Logout successfull",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set('token','',cookiesOption)

        return response
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\register\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import uploadImage from '@/helpers/uploadImage'
import connectDB from '@/database/db'

connectDB()

export async function POST(request){
    try {
        const formData = await request.formData()
        const firstName = formData.get('firstName')
        const lastName = formData.get('lastName')
        const location = formData.get('location')
        const occupation = formData.get('occupation')
        const email  = formData.get('email')
        const password = formData.get('password')
        const profilePic = formData.get('profile_pic')

        //checking email id
        const checkEmailid = await userModel.findOne({ email })
        if(checkEmailid){
            return NextResponse.json({ message  : "Already exits user"})
        }

        //password into hash format
        const salt = await bcryptjs.genSalt(10)
        const hashPassword = await bcryptjs.hash(password , salt)

        //upload profile pic in cloudinary
        let uploadProfilePic = ''
        if(profilePic?.name){
            uploadProfilePic = await uploadImage(profilePic)
        } 
        
        const payload = {
            firstName,
            lastName,
            location,
            occupation,
            email,
            password : hashPassword,
            profile_pic : uploadProfilePic.url,
            profileViews : Math.floor(Math.random() * 1000),  
            profileImpressions : Math.floor(Math.random() * 1000),
        }

        const user  = new userModel(payload)
        const saveUserData = await user.save()

        return NextResponse.json({message : "User created successfully", data : saveUserData, success : true })

    } catch (error) {
        return NextResponse.json({ message : error.message || error })
    }
}

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 1: User Authentication and Authorization`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,447 - INFO - RESPONSE (from cache): # Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

2025-05-30 19:09:12,447 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "User Data Model". This is Chapter 2.

Concept Details:
- Name: User Data Model
- Description:
This defines the structure and properties of a user, such as name, email, password, and profile picture. It is like a blueprint for creating user objects in the database. The user model ensures all user data is consistent and contains the necessary information to represent a user in the application.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\models\userModel.js ---
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        min : 3,
        max : 100,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        min : 3,
        max : 100,
        required : [true, "Provide last name"]
   },
   location : {
        type : String,
        default : ""
   },
   occupation : {
        type : String,
        default : ""
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   },
   profile_pic : {
        type : String,
        default : ""
   },
   profileViews : {
        type : Number,
        min : 0,
        default : 0
   },
   profileImpressions : {
        type : Number,
        min : 0,
        default : 0
   },
   friends : {
     type : Array,
     default : []
   }
},{
    timeStamps : true
})


const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)


export default userModel

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 2: User Data Model`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,527 - INFO - RESPONSE (from cache): # Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

2025-05-30 19:09:12,527 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "API Route Handlers". This is Chapter 3.

Concept Details:
- Name: API Route Handlers
- Description:
These are functions that handle incoming HTTP requests to the server.  Think of them as waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals).  Each handler is responsible for a specific endpoint, like `/api/login` or `/api/register`.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\app\api\add-remove-friends\route.js ---
import connectDB from "@/database/db";
import { getUserDetailsFromToken } from "@/helpers/getUserDetailsFromToken";
import userModel from "@/models/userModel";
import { NextResponse } from 'next/server'

connectDB()
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        const { friendId } = await request.json()

        const currentUserFriendList = user.friends || []
        /**add friends */
        if(!currentUserFriendList.includes(friendId)){
             await userModel.updateOne({ _id : user._id },{
                $push : { friends : friendId }
            })


            await userModel.updateOne({ _id : friendId },{
                $push : { friends : user._id?.toString() }
            })

            return NextResponse.json({
                message : "friend added",
                success : true
            })
        }

        //remove friend 
        await userModel.updateOne({ _id : user._id },{
            $pull : { friends : friendId }
        })


        await userModel.updateOne({ _id : friendId },{
            $pull : { friends : user._id?.toString() }
        })

        return NextResponse.json({
            message : "friend remove",
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\all-users\route.js ---
import { NextResponse } from "next/server";
import connectDB from "@/database/db";
import userModel from "@/models/userModel";

connectDB()
export async function GET(){
   try {
        const users = await userModel.find()

        const usersDetailsList = users.map(user =>{
            return {
                _id : user._id,
                firstName : user.firstName,
                lastName : user.lastName,
                occupation : user.occupation,
                profile_pic : user.profile_pic
            }
        })

        return NextResponse.json({
            message : "all users",
            data : usersDetailsList,
            success : true
        })
   } catch (error) {
     return NextResponse.json({
        message : error.message || error,
        error : true
     })
   } 
}

--- File: src\app\api\current-user\route.js ---
import { getUserDetailsFromToken } from "@/helpers/getUserDetailsFromToken";
import { NextResponse } from "next/server";
import connectDB from "@/database/db";

connectDB()
export async function GET(request){
    try {
        const user =  await getUserDetailsFromToken(request)
        
        return NextResponse.json({
            message : "Current user Details",
            data : user
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\friends\route.js ---
import { NextResponse } from 'next/server'
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import userModel from '@/models/userModel'


connectDB()
export async function GET(request){
    try {
        const user = await getUserDetailsFromToken(request)

        const friendListId = user.friends || []

        const friendslist = await userModel.find({
            _id : { $in : friendListId }
        })

        const friends =  friendslist.map((userData)=>{
            return{
                _id : userData._id,
                firstName : userData.firstName,
                lastName : userData.lastName,
                occupation : userData.occupation,
                profile_pic : userData.profile_pic
            }
        })

        return NextResponse.json({
            message : 'friend list',
            data :friends,
            success :true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\login\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import jwt from 'jsonwebtoken'
import connectDB from '@/database/db'

connectDB() 

export async function POST(request){
    try {
        const { email , password } = await request.json()

        const user = await userModel.findOne({ email })

        if(!user){
            return NextResponse.json({message : "user not exit!"},{status : 400})
        }

        const checkPassword = await bcryptjs.compare(password,user.password)

        if(!checkPassword){
            return NextResponse.json({ message : "Check your password"})
        }

        const tokenData = {
            id : user._id,
            email : user.email
        }

        const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})

        const response =  NextResponse.json({
            token : token,
            message : "Login successfully",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set("token",token,cookiesOption)
        
        return response
 
    } catch (error) {
       return NextResponse.json({ message : error.message || error })
    }
}

--- File: src\app\api\logout\route.js ---
import { NextResponse } from 'next/server'

export async function GET(){
    try {
        const response = NextResponse.json({
            message : "Logout successfull",
            success : true
        })

        const cookiesOption = {
            httpOnly : true,
            secure : true,
        }

        response.cookies.set('token','',cookiesOption)

        return response
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\post\route.js ---
import connectDB from '@/database/db'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()
export async function GET(){
    try {
        const post = await postModel.find().populate('userId').sort({ createdAt : -1})

        return NextResponse.json({
            data : post,
            message : "post",
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\post\comment\route.js ---
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()


/***save commment */
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const { description , postId } = await request.json()

        const payload  = {
            description :  description,
            userId : user._id
        }

        const commentPost = await postModel.updateOne({ _id : postId},{
            $push : { comment : payload }
        })

        const commentList = await postModel.find({ _id : postId}).populate({
            path : 'comment',
            populate : {
                path : 'userId'
            }
        })

        return NextResponse.json({
            message : "Comment",
            data : commentList,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\post\get-comment-for-post\route.js ---
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()


/***save commment */
export async function POST(request){
    try {
        const user  = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const {  postId } = await request.json()

        const commentList = await postModel.findOne({ _id : postId }).populate({
            path : 'comment',
            populate : {
                path : 'userId'
            }
        })

        return NextResponse.json({
            message : "Comment",
            data : commentList,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\post\like\route.js ---
import connectDB from '@/database/db'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import postModel from '@/models/postModel'
import { NextResponse } from 'next/server'

connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        const { _id } = await request.json()

        const post = await postModel.findOne({ _id : _id })

        /*checkin user id is availabe in like array*/
        if(post.like.includes(user.id)){
            const updatePost = await postModel.updateOne({ _id : _id },{
               $pull : { like : user._id}
            })

            const postData = await postModel.findOne({ _id : _id })
            return NextResponse.json({
                message : "Like",
                data : postData.like,
                success : true
            })
        }

        const updataPost = await postModel.updateOne({ _id : _id },{
            $push : { like : user._id}
         })

        const postData = await postModel.findOne({ _id : _id })

        return NextResponse.json({
            message : 'Liked',
            data : postData.like,
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}

--- File: src\app\api\register\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import uploadImage from '@/helpers/uploadImage'
import connectDB from '@/database/db'

connectDB()

export async function POST(request){
    try {
        const formData = await request.formData()
        const firstName = formData.get('firstName')
        const lastName = formData.get('lastName')
        const location = formData.get('location')
        const occupation = formData.get('occupation')
        const email  = formData.get('email')
        const password = formData.get('password')
        const profilePic = formData.get('profile_pic')

        //checking email id
        const checkEmailid = await userModel.findOne({ email })
        if(checkEmailid){
            return NextResponse.json({ message  : "Already exits user"})
        }

        //password into hash format
        const salt = await bcryptjs.genSalt(10)
        const hashPassword = await bcryptjs.hash(password , salt)

        //upload profile pic in cloudinary
        let uploadProfilePic = ''
        if(profilePic?.name){
            uploadProfilePic = await uploadImage(profilePic)
        } 
        
        const payload = {
            firstName,
            lastName,
            location,
            occupation,
            email,
            password : hashPassword,
            profile_pic : uploadProfilePic.url,
            profileViews : Math.floor(Math.random() * 1000),  
            profileImpressions : Math.floor(Math.random() * 1000),
        }

        const user  = new userModel(payload)
        const saveUserData = await user.save()

        return NextResponse.json({message : "User created successfully", data : saveUserData, success : true })

    } catch (error) {
        return NextResponse.json({ message : error.message || error })
    }
}

--- File: src\app\api\upload-post\route.js ---
import connectDB from '@/database/db'
import { NextResponse } from 'next/server'
import postModel from '@/models/postModel'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import uploadImage from '@/helpers/uploadImage'


connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const formdata = await request.formData()
        const description = formdata.get("description")
        const image = formdata.get("image")

        let postUpload = ''
        if(image){
            postUpload = await uploadImage(image)
        } 

        const payload =  {
            image : postUpload.url,
            description : description,
            userId : user._id
        }

        const post = new postModel(payload)
        const savePost = await post.save()

        return NextResponse.json({
            message : "Upload successfully",
            success : true,
            data : savePost
        })

    } catch (error) {
        return NextResponse.json({ message : error.message || message })
    }   
}

--- File: src\app\api\user-details\route.js ---
import { NextResponse } from 'next/server'
import connectDB from '@/database/db'
import userModel from '@/models/userModel'
import postModel from '@/models/postModel'

connectDB()

export async function POST(request){
    try {
        const { userId } = await request.json()

        //user
        const user   = await userModel.findOne({ _id : userId})


        //friends
        const friendListId = user.friends || []
        const friendslist = await userModel.find({
            _id : { $in : friendListId }
        })
        const friends =  friendslist.map((userData)=>{
            return{
                _id : userData._id,
                firstName : userData.firstName,
                lastName : userData.lastName,
                occupation : userData.occupation,
                profile_pic : userData.profile_pic
            }
        })

        //post
        const post = await postModel.find({ userId : userId }).populate('userId').sort({ createdAt : -1})

        return NextResponse.json({
            data : user,
            friends : friends,
            post : post,
            message : 'user details',
            success : true
        })
    } catch (error) {
        return NextResponse.json({
            message : error.message || error,
            error : true
        })
    }
}

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 3: API Route Handlers`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,596 - INFO - RESPONSE (from cache): # Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.

2025-05-30 19:09:12,596 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "Post Data Model". This is Chapter 4.

Concept Details:
- Name: Post Data Model
- Description:
This abstraction represents a social media post, including its content (description, image), the user who created it, likes, and comments. It's the structure of data of each post. It's like a template to standardize new data that is added to the system.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

---
# Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\models\postModel.js ---
import mongoose , { Schema } from 'mongoose'

const commentSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    }
},{
    timestamps : true
})


const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    image : {
        type : String,
        default : ""
    },
    userId : {
        type : Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    },
    comment : [commentSchema]
},{
    timestamps : true
})


const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 4: Post Data Model`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,645 - INFO - RESPONSE (from cache): # Chapter 4: Post Data Model

Welcome back! In [Chapter 3: API Route Handlers](03_api_route_handlers.md), we learned how to handle requests to create, update, and delete data. But what *is* that data we're working with when it comes to posts? That's where the **Post Data Model** comes in!

Imagine you're scrolling through your LinkedIn feed. Every post you see has some text, maybe an image, the user who posted it, and some likes and comments. The Post Data Model is like a template that defines what information each post contains and how it's organized.

Think of it like this: if the User Data Model (which you learned about in [Chapter 2: User Data Model](02_user_data_model.md)) is a blueprint for how to store user information, the Post Data Model is a blueprint for how to store post information!

**Why do we need a Post Data Model?**

Just like we needed a User Data Model to keep user data organized, we need a Post Data Model to keep post data organized. Without it, our application wouldn't know what to expect from each post, and it would be difficult to display and manage posts correctly.

Specifically, the Post Data Model ensures:

1.  **Consistency:** Every post has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a post.
3.  **Structure:** We know exactly where to find each piece of information for every post.

**Key Concepts:**

Let's break down what makes up our Post Data Model. It defines the properties (or attributes) of a post.

*   **Properties:** These are the individual pieces of information we store about each post. Examples include:

    *   `description`: The text content of the post (e.g., "Excited to share this article!").
    *   `image`: A link to an image in the post (if any).
    *   `userId`: The ID of the user who created the post. This links the post back to the user.
    *   `like`: An array containing the IDs of users who liked the post.
    *   `comment`: An array of comments related to the post.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., description, image URLs).
    *   `Array`: A list of things (e.g., a list of user IDs who liked the post, a list of comments).
    *   `ObjectId`: A special type of ID used to link data between different parts of our database (e.g., linking a post to a user).

**How do we use the Post Data Model?**

Let's say we want to create a new post in our application. We'd use the Post Data Model as a template. We'd provide the necessary information (description, image URL, user ID), and our application would create a new post object based on the model.

Here's a simplified example (conceptually):

```javascript
const newPost = {
  description: "Check out my new project!",
  image: "https://example.com/image.jpg",
  userId: "654321abcdef0123456789" // The ID of the user who created the post
};
```

This `newPost` object now has the structure defined by our Post Data Model.

**Internal Implementation:**

Let's take a peek under the hood! When a user creates a new post, here's what happens:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/create)
    participant Post Data Model
    participant Database

    User->>Client-side App: Creates a new post
    Client-side App->>API Route (/api/post/create): Sends post data (description, image, userId)
    API Route (/api/post/create)->>Post Data Model: Creates a new post object based on model
    Post Data Model->>Database: Saves the new post object
    Database-->>API Route (/api/post/create): Returns success or error
    API Route (/api/post/create)-->>Client-side App: Returns success or error
    Client-side App->>User: Displays the new post
```

1.  **User Input:** The user creates a new post in the Client-side App.
2.  **API Request:** The Client-side App sends the post data to the `/api/post/create` route.
3.  **Model Creation:** The `/api/post/create` route uses the Post Data Model as a blueprint to create a new post object.
4.  **Database Save:** The new post object is saved to the database.

Now, let's look at the actual code in `src\models\postModel.js`:

```javascript
import mongoose from 'mongoose'

const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : mongoose.Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    }
},{
    timestamps : true
})

const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel
```

Let's break it down:

*   `mongoose.Schema({...})`: This defines the structure of our post data.
*   `description : { type : String, default : "" }`: This says the `description` property must be a string, and if no description is provided, it defaults to an empty string.
*   `userId : { type : mongoose.Schema.Types.ObjectId, required : true, ref : 'users' }`: This says the `userId` property must be a special `ObjectId` that links to a user in the `users` collection.  `required : true` means a post can't be created without a user ID. `ref : 'users'` means this ID refers to a document in the `users` collection.
*   `timestamps: true`: This option lets the database automatically create `createdAt` and `updatedAt` fields.

```javascript
    like : {
         type : Array,
         default : []
    }
```

This snippet creates an Array which contains the list of users who "liked" the post.

The code from [API Route Handlers](03_api_route_handlers.md) which likes a post uses this model!

**Conclusion:**

In this chapter, we learned about the Post Data Model. We saw how it acts as a blueprint for post data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and how they're used to represent a post in our application.

Next, we'll explore the [Context Provider (ContextData)](05_context_provider__contextdata_.md), which helps us share data across different parts of our application.

2025-05-30 19:09:12,658 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "Context Provider (ContextData)". This is Chapter 5.

Concept Details:
- Name: Context Provider (ContextData)
- Description:
This is a way to share data (like the current user) across different components without having to pass it down manually through props. Think of it like a central information hub. Components can subscribe to the context to get the latest data and react to changes.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

---
# Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.

---
# Chapter 4: Post Data Model

Welcome back! In [Chapter 3: API Route Handlers](03_api_route_handlers.md), we learned how to handle requests to create, update, and delete data. But what *is* that data we're working with when it comes to posts? That's where the **Post Data Model** comes in!

Imagine you're scrolling through your LinkedIn feed. Every post you see has some text, maybe an image, the user who posted it, and some likes and comments. The Post Data Model is like a template that defines what information each post contains and how it's organized.

Think of it like this: if the User Data Model (which you learned about in [Chapter 2: User Data Model](02_user_data_model.md)) is a blueprint for how to store user information, the Post Data Model is a blueprint for how to store post information!

**Why do we need a Post Data Model?**

Just like we needed a User Data Model to keep user data organized, we need a Post Data Model to keep post data organized. Without it, our application wouldn't know what to expect from each post, and it would be difficult to display and manage posts correctly.

Specifically, the Post Data Model ensures:

1.  **Consistency:** Every post has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a post.
3.  **Structure:** We know exactly where to find each piece of information for every post.

**Key Concepts:**

Let's break down what makes up our Post Data Model. It defines the properties (or attributes) of a post.

*   **Properties:** These are the individual pieces of information we store about each post. Examples include:

    *   `description`: The text content of the post (e.g., "Excited to share this article!").
    *   `image`: A link to an image in the post (if any).
    *   `userId`: The ID of the user who created the post. This links the post back to the user.
    *   `like`: An array containing the IDs of users who liked the post.
    *   `comment`: An array of comments related to the post.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., description, image URLs).
    *   `Array`: A list of things (e.g., a list of user IDs who liked the post, a list of comments).
    *   `ObjectId`: A special type of ID used to link data between different parts of our database (e.g., linking a post to a user).

**How do we use the Post Data Model?**

Let's say we want to create a new post in our application. We'd use the Post Data Model as a template. We'd provide the necessary information (description, image URL, user ID), and our application would create a new post object based on the model.

Here's a simplified example (conceptually):

```javascript
const newPost = {
  description: "Check out my new project!",
  image: "https://example.com/image.jpg",
  userId: "654321abcdef0123456789" // The ID of the user who created the post
};
```

This `newPost` object now has the structure defined by our Post Data Model.

**Internal Implementation:**

Let's take a peek under the hood! When a user creates a new post, here's what happens:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/create)
    participant Post Data Model
    participant Database

    User->>Client-side App: Creates a new post
    Client-side App->>API Route (/api/post/create): Sends post data (description, image, userId)
    API Route (/api/post/create)->>Post Data Model: Creates a new post object based on model
    Post Data Model->>Database: Saves the new post object
    Database-->>API Route (/api/post/create): Returns success or error
    API Route (/api/post/create)-->>Client-side App: Returns success or error
    Client-side App->>User: Displays the new post
```

1.  **User Input:** The user creates a new post in the Client-side App.
2.  **API Request:** The Client-side App sends the post data to the `/api/post/create` route.
3.  **Model Creation:** The `/api/post/create` route uses the Post Data Model as a blueprint to create a new post object.
4.  **Database Save:** The new post object is saved to the database.

Now, let's look at the actual code in `src\models\postModel.js`:

```javascript
import mongoose from 'mongoose'

const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : mongoose.Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    }
},{
    timestamps : true
})

const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel
```

Let's break it down:

*   `mongoose.Schema({...})`: This defines the structure of our post data.
*   `description : { type : String, default : "" }`: This says the `description` property must be a string, and if no description is provided, it defaults to an empty string.
*   `userId : { type : mongoose.Schema.Types.ObjectId, required : true, ref : 'users' }`: This says the `userId` property must be a special `ObjectId` that links to a user in the `users` collection.  `required : true` means a post can't be created without a user ID. `ref : 'users'` means this ID refers to a document in the `users` collection.
*   `timestamps: true`: This option lets the database automatically create `createdAt` and `updatedAt` fields.

```javascript
    like : {
         type : Array,
         default : []
    }
```

This snippet creates an Array which contains the list of users who "liked" the post.

The code from [API Route Handlers](03_api_route_handlers.md) which likes a post uses this model!

**Conclusion:**

In this chapter, we learned about the Post Data Model. We saw how it acts as a blueprint for post data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and how they're used to represent a post in our application.

Next, we'll explore the [Context Provider (ContextData)](05_context_provider__contextdata_.md), which helps us share data across different parts of our application.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\app\(root)\page.js ---
'use client'
import ProfileCard from "@/components/ProfileCard";
import UploadPost from "@/components/UploadPost";
import { ContextData } from "@/providers/provider";
import { useContext, useEffect, useState } from "react";
import axios from 'axios'
import PostDisplay from "@/components/PostDisplay";
import Avatar from "@/components/Avatar";
import Divider from "@/components/Divider";
import handleAddRemoveFriends from "@/helpers/handleAddRemoveFriends";
import toast from 'react-hot-toast'
import News from "@/components/News";

export default function Home() {
  const {user, fetchCurrentUserDetails} = useContext(ContextData)
  const [postData,setPostData] = useState([])
  const [friendsList,setFriendsList] = useState([])

  const fetchPost = async()=>{
    const response = await axios.get("/api/post")
    setPostData(response.data.data || [])
  }

  const fetchFriendsList = async()=>{
    const response = await axios.get('/api/friends')
    setFriendsList(response.data.data)
  }

  useEffect(()=>{
    fetchPost()
    fetchFriendsList()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchFriendsList()
    toast(response.message)
  }

  return (
   <div className="container mx-auto p-4 lg:grid grid-cols-[280px,1fr,280px] gap-7 h-full items-start">
        {/*** current user profile*/}
        <section className="bg-white rounded p-2 lg:sticky lg:top-20">
          <ProfileCard
            _id={user?._id}
            profile_pic={user?.profile_pic}
            firstName={user?.firstName || ''}
            lastName={user?.lastName || ''}
            location={user?.location || ''}
            occupation={user?.occupation || ''}
            friends = {user?.friends || []}
          />
          <hr className="m-3"/>
          <h1 className="font-bold mb-3">Your Connections:</h1>
            <div>
              {
                friendsList.map((friend,index)=>{
                  return(
                    <div key={friend?._id}>
                      <div className="flex items-center gap-3 justify-between">
                        <div className="flex items-center gap-3">
                          <Avatar
                            userId={friend._id}
                            width={40}
                            height={40}
                            imageURL={friend?.profile_pic}
                          />
                          <div>
                            <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                            <p className="text-xs">{friend.occupation}</p>
                          </div>
                        </div>
                        <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                      </div>
                      <Divider/>
                    </div>
                  )
                })
              }
            </div>
        </section>


        {/*** upload post and see post*/}
        <section className="rounded mt-5 lg:mt-0">
            <UploadPost
               _id={user?._id}
               profile_pic={user?.profile_pic}
               callApi={fetchPost}
            />

            <div>
                {
                  postData.map((post,index)=>{
                    return(
                      <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                    )
                  })
                }
            </div>

        </section>


         {/*** ads and friend list*/}
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
            <div className="flex flex-row">
            <News/>
            </div>
        </section>
   </div>
  );
}

--- File: src\app\(root)\find-friends\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import { ContextData } from '@/providers/provider'
import toast from 'react-hot-toast'

const FindFriends = () => {
  const [allUser,setAllUser] = useState([])
  const {user, fetchCurrentUserDetails} = useContext(ContextData)

  const fetchAllUser = async()=>{
    const response = await axios.get("/api/all-users")
    const friendList = user?.friends || []
    const removeFriends = response.data.data.filter(userDetails => !friendList.includes(userDetails?._id))
    const removeCurrentUser = removeFriends.filter(userDetails => userDetails?._id !== user?._id) 
    setAllUser(removeCurrentUser)
  }

  useEffect(()=>{
    fetchAllUser()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchAllUser()
    toast(response.message)
  }
  return (
    <div className='container mx-auto p-4'>

        <h3 className='font-semibold text-lg mb-3'>Find <span className='text-orange-500 font-extrabold'>New</span> Friends</h3>
        <div className='flex flex-wrap gap-4'>
          {
              allUser.map((user,index)=>{
                return(
                  <div key={index} className='bg-white p-4 flex justify-center flex-col items-center gap-1 min-w-[180px] min-h-[180px]'>
                      <Avatar
                        userId={user?._id}
                        imageURL={user?.profile_pic}
                        width={60}
                        height={60}
                      />
                      <p className='text-lg font-medium capitalize my-0'>{user.firstName} {user.lastName}</p>
                      <p className='text-xs my-0 -mt-2'>{user.occupation}</p>
                      <button className='bg-blue-800 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm mt-2' onClick={()=>handleAddFriend(user?._id)}>Add Friend</button>
                  </div>
                )
              })
          }
        </div>

    </div>
  )
}

export default FindFriends

--- File: src\app\(root)\[id]\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import { ContextData } from '@/providers/provider'
import PostDisplay from '@/components/PostDisplay'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import Divider from '@/components/Divider'

const UserProfileDetails = ({ params }) => {
    const [data,setData] = useState(null)
    const [friendslist,setFirendsList] = useState([])
    const [postData,setPostData] = useState([])
    const {user, fetchCurrentUserDetails} = useContext(ContextData)
    const [loading,setLoading] = useState(false)
    
    const fetchUserDetails  = async()=>{
      const payload  = {
        userId : params.id
      }
      setLoading(true)
      const response  = await axios.post("/api/user-details",payload)

      setData(response.data.data)
      setFirendsList(response.data.friends)
      setPostData(response.data.post)
      setLoading(false)
    }

    const handleAddFriend = async(friendId)=>{
      const response = await handleAddRemoveFriends(friendId)
      fetchUserDetails()
    }

    useEffect(()=>{
      fetchUserDetails()
    },[])

    const isDisplayAddFriend = user?.friends?.includes(data?._id) || user?._id === data?._id
  return (
    <div className='container mx-auto'>

        <div className='mt-5 grid gap-10 lg:grid-cols-[2fr,1fr] items-start'>
            {/**user information and post */}
            <div className=''>
                {/**user information */}
                <div className='bg-white p-4'>
                      <div className='h-36 bg-slate-200 rounded mb-14'>
                          <div className='bg-white h-36 w-36 rounded-full translate-x-8 translate-y-1/3 p-1 flex justify-center items-center'>
                              <Avatar
                                imageURL={data?.profile_pic}
                                userId={data?._id}
                                width={130}
                                height={130}
                              />
                          </div>
                      </div>
                      <p className='font-bold text-lg lg:text-2xl capitalize'>{data?.firstName} {data?.lastName}</p>
                      <p className='text-base lg:text-lg'>{data?.occupation}</p>

                      {
                        !isDisplayAddFriend && (
                          <button className='bg-blue-800 hover:bg-blue-700 text-white font-semibold px-5 rounded-full my-3 py-2'>Add Friend</button>
                        )
                      }
                </div>

                {/***post */}
                    <div className='w-full'>
                    {
                      postData.map((post,index)=>{
                        return(
                          <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                        )
                      })
                    }
                  </div> 
            </div>
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
              
              <h1 className="font-bold mb-3">Friends List:</h1>
              <div>
                {
                  friendslist.map((friend,index)=>{
                    return(
                      <div key={friend?._id}>
                        <div className="flex items-center gap-3 justify-between">
                          <div className="flex items-center gap-3">
                              <Avatar
                                userId={friend._id}
                                width={40}
                                height={40}
                                imageURL={friend?.profile_pic}
                              />
                              <div>
                                <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                                <p className="text-xs">{friend.occupation}</p>
                              </div>
                          </div>
                          <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                        </div>

                        <Divider/>
                      </div>
                    )
                  })
                }
              </div>
  
          </section>


        </div>


        {
          loading && (
            <div className='fixed top-0 bottom-0 right-0 left-0 bg-slate-500 bg-opacity-25 flex justify-center items-center'>
              <p className='bg-white px-6 py-2 text-lg'>Loading...</p>
            </div>
          )
        }
    </div>
  )
}

export default UserProfileDetails

--- File: src\components\Header.js ---
'use client'
import React, { useContext, useState } from 'react'
import Image from 'next/image'
import { headerNavLink } from '@/constants'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import axios from 'axios'
import toast from 'react-hot-toast'
import { useRouter } from 'next/navigation'
import { ContextData } from '@/providers/provider'
import Avatar from './Avatar'
import { Search } from 'lucide-react'

const Header = () => {
    const path = usePathname()
    const router = useRouter()
    const [openUserMenu, setOpenUserMenu] = useState(false)
    const { user, fetchCurrentUserDetails } = useContext(ContextData)

    const handleOpenClose = () => {
        setOpenUserMenu((prev) => !prev)
    }

    const handleUserLogout = async () => {
        const response = await axios.get('/api/logout')
        setOpenUserMenu(false)
        toast(response?.data.message)
        router.push("/login")
    }

    return (
        <header className='h-16 bg-white sticky z-40 shadow top-0'>
            <div className='container mx-auto h-full flex items-center px-4 justify-between'>
                <div className='grid grid-cols-[170px,1fr] items-center'>
                    <Link href={"/"}>
                        <Image 
                            src={'/logo.png'}
                            width={190}
                            height={70}
                            alt='logo'
                        />
                    </Link>

                    {/* Search input */}
                    <div className='w-full items-center gap-2 border bg-slate-100 px-1 rounded hidden lg:flex'>
                        <input 
                            type='text' 
                            placeholder='Search here...'
                            className='w-full max-w-52 bg-slate-100 py-1 px-2 outline-none'
                        />
                        <Search />
                    </div>
                </div>

                <div className='flex items-center gap-10 h-full'>
                    {/* Navbar */}
                    <nav className='hidden lg:flex items-center gap-4 h-full'>
                        {headerNavLink.map((navlink, index) => { 
                            const isActive = path === navlink.route
                            const Icon = navlink.icon
                            return (
                                <Link 
                                    href={navlink.route}
                                    key={index}
                                    className={`flex flex-col justify-center items-center gap-1 h-full px-4 ${isActive ? 'bg-slate-100' : ''}`}
                                >
                                    <Icon />
                                    <p className='text-sm'>{navlink.label}</p>
                                </Link>
                            )
                        })}
                    </nav>

                    <div>
                        {/* Current user login image */}
                        <div className='flex flex-col justify-center items-center cursor-pointer relative'>
                            <div onClick={handleOpenClose} className='flex flex-col justify-center items-center'>
                                <Avatar
                                    userId={user?._id}
                                    imageURL={user?.profile_pic}
                                    width={28}
                                    height={28}
                                    disable={true}
                                />
                                <p className='text-sm'>Me</p>
                            </div>
                            
                            {/* User menu */}
                            {openUserMenu && (
                                <div className='shadow absolute top-14 right-0 min-w-60 p-4 rounded bg-white'>
                                    <div className='font-semibold text-center flex flex-col justify-center items-center'>
                                        <Avatar
                                            userId={user?._id}
                                            imageURL={user?.profile_pic}
                                            width={45}
                                            height={45}
                                            extraWidth={20}
                                            extraHeight={20}
                                        />
                                        <p className='text-lg'>
                                            { user?.firstName + " " + user?.lastName }
                                        </p>
                                        <p className='text-sm'>
                                            {user?.occupation}
                                        </p>
                                    </div>

                                    <div className='p-[0.5px] my-1 bg-slate-200'></div>

                                    {/* Mobile responsive */}
                                    <nav className='flex lg:hidden justify-center flex-col gap-2 h-full'>
                                        {headerNavLink.map((navlink, index) => { 
                                            const isActive = path === navlink.route
                                            const Icon = navlink.icon
                                            return (
                                                <Link 
                                                    href={navlink.route}
                                                    key={index}
                                                    className={`flex flex-row gap-2 h-full px-4 py-3 ${isActive ? 'bg-slate-100' : ''}`}
                                                    onClick={handleOpenClose}
                                                >
                                                    <Icon />
                                                    <p className='text-sm'>{navlink.label}</p>
                                                </Link>
                                            )
                                        })}
                                    </nav>

                                    <button className='bg-red-600 text-white rounded hover:bg-red-700 w-full py-1' onClick={handleUserLogout}>Logout</button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        </header>
    )
}

export default Header


--- File: src\components\PostDisplay.js ---
import React, { useContext, useEffect, useState } from 'react'
import Avatar from './Avatar'
import Image from 'next/image'
import { ContextData } from '@/providers/provider'
import axios from 'axios'
import { MessageSquare, Share, UserPlus } from 'lucide-react'

const PostDisplay = ({ data ,handleAddFriend }) => {
    const [likeData,setLikeData] = useState(data?.like || [])
    const [commentData,setCommentData] = useState(data?.comment || [])
    const [openComment,setOpenComment] = useState(false)
    const [comment,setComment] = useState('')

    const {user, fetchCurrentUserDetails} = useContext(ContextData)


    const handleLikePost = async()=>{
        const payload = {
            _id : data?._id
        }
        const response = await axios.post('/api/post/like',payload)

        setLikeData(response.data.data)
    }


    const handleOpenCloseComment = () =>{
        setOpenComment(preve => !preve)
    }

    const fetchCommentData = async() =>{
        const payload  = {
            postId : data?._id
        }
        const response = await axios.post("api/post/get-comment-for-post",payload)

        setCommentData(response.data.data.comment || [])
    }

    useEffect(()=>{
        if(openComment){
            fetchCommentData()
        }
    },[])


    const handleuploadComment = async() =>{
        const payload = {
            description : comment,
            postId : data?._id
        }
        if(comment){
            const response  = await axios.post("api/post/comment",payload)
            setComment('')
            fetchCommentData()
        }
        
    }
    


    const currentUserLiked = likeData.includes(user?._id)
    const isDisplayAddFriend = user?.friends?.includes(data?.userId?._id) || user?._id === data?.userId?._id
  return (
    <div className='bg-white p-4 my-6'>
        <div className='flex gap-3 items-center justify-between'>
            <div className='flex gap-3 items-center'>
                <Avatar
                    userId={data.userId._id}
                    imageURL={data.userId.profile_pic}
                    width={40}
                    height={40}
                />
                <div>
                    <p className='font-bold'>{data.userId.firstName} {data.userId.lastName}</p>
                    <p className='text-xs'>{data.userId.occupation}</p>
                </div>
            </div>

            {
                !isDisplayAddFriend && (
                    <div className='bg-white shadow-md p-2 rounded-full flex justify-center items-center cursor-pointer hover:bg-blue-700' onClick={()=>handleAddFriend(data?.userId?._id)}>
                        <UserPlus/>
                    </div>
                )
            }
           
        </div>

        <p className='py-3'>
            {data.description}
        </p>

        <div className='w-full h-full'>
            {
                data.image && (
                    <Image 
                        src={data.image}
                        width={1000}
                        height={1000}
                        alt='post'
                    />
                )
            }
        </div>


        <div className='text-sm flex items-center justify-between mt-3'>
             {/**like count */}
            <div>
                {likeData.length  === 0 ? "You're first to like" : likeData.length + " Likes"  }
            </div>

            {/**comment count */}
            <div>
                {commentData.length} comment
            </div>

        </div>

        <div className='p-[0.5px] bg-slate-200'></div>

        
        <div className='py-1 flex justify-between gap-3'>
             {/**like */}
             <div className='flex items-center gap-1 cursor-pointer' onClick={handleLikePost}>
                {
                    currentUserLiked ? (
                        <Image
                            src={'/liked.svg'}
                            width={20}
                            height={20}
                            alt='like' 
                        />
                    ) : (
                        <Image
                        src={'/like.svg'}
                        width={20}
                        height={20}
                        alt='like' 
                        />
                    )
                }
                
                <p  className={currentUserLiked && 'text-blue-800 font-semibold'}>Like</p>
             </div>


              {/**comment */}
              <div className='flex items-center gap-1 cursor-pointer hover:text-blue-700' onClick={handleOpenCloseComment}>
                    <MessageSquare/>
                    <p>Comment</p>  
              </div>


            {/**share */}
            <div>
                <div className='flex items-center gap-1 cursor-pointer'>
                <Share/>
                <p>Share</p> 
                </div>
            </div>
        </div>


        {/****display all the comment */}
        {
            openComment && (
                <div className='p-4 bg-white w-full'>
                     <div className='flex items-center gap-4 w-full'>
                        <Avatar
                            userId={user._id}
                            imageURL={user.profile_pic}
                            width={40}
                            height={40}
                            alt={user.firstName}
                        />
                        <div className='w-full flex gap-1'>
                            <input 
                                type='text' 
                                placeholder='type comment here...' 
                                className='bg-slate-100 rounded-full px-4 py-2 w-full outline-none' 
                                onChange={(e)=>setComment(e.target.value)}
                                value={comment}
                            />
                            <button className='bg-blue-700 text-white text-sm px-3 py-1 rounded-full' onClick={handleuploadComment}>Send</button>
                        </div>
                    </div>


                    {/**list of comment */}
                    <div className='mt-3'>
                        {
                            commentData.map((comment,index)=>{
                                return(
                                    <div className='ml-5 p-2 border-b' key={comment?._id}>
                                        <div className='flex gap-3 items-center'>
                                            <Avatar
                                                userId={comment?.userId?._id}
                                                imageURL={comment?.userId?.profile_pic}
                                                width={30}
                                                height={30}
                                                alt={comment?.userId?.firstName}
                                            />
                                            <div className='flex flex-col'>
                                                <p className='font-semibold text-sm'>{comment?.userId?.firstName} {comment?.userId?.lastName}</p>
                                                <p className='text-xs -mt-1'>{comment?.userId?.occupation}</p>
                                            </div>
                                        </div> 
                                        <div className='text-sm py-1 px-2'>
                                            {comment.description}
                                        </div>   
                                    </div>
                                )
                            })
                        }
                    </div>

                    
                </div>
            )
        }
    </div>
  )
}

export default PostDisplay

--- File: src\providers\provider.js ---
'use client'

import axios from "axios";
import { createContext, useEffect, useState } from "react";

export const ContextData = createContext(null)

export const Provider = ({children}) =>{
    const [user,setData] = useState(null)

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return(
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    )
}

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 5: Context Provider (ContextData)`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,712 - INFO - RESPONSE (from cache): # Chapter 5: Context Provider (ContextData)

Welcome back! In [Chapter 4: Post Data Model](04_post_data_model.md), we learned how to structure post data in our LinkedIn clone. But what if we want to show the currently logged-in user's name and profile picture in multiple places on the page, like the header and the post upload section? We *could* pass the user data as props to each component, but that can get messy and repetitive! That's where the **Context Provider (ContextData)** comes to the rescue!

Think of ContextData like a central bulletin board where you can pin important information that many different components need to access. In our case, that information is the currently logged-in user. Any component that needs the user's information can simply "read" it from the ContextData, without having to receive it directly as a prop from its parent.

**Why do we need a Context Provider?**

Imagine you're building a house. You could run individual electrical wires from the power source to each light fixture, but that's inefficient. Instead, you use a central electrical panel to distribute power to all the rooms. Context Provider is like that electrical panel  it provides a central place to manage and share data across your application.

Specifically, Context Provider helps us:

1.  **Avoid Prop Drilling:** We don't have to pass data through multiple layers of components that don't actually need it.
2.  **Centralize Data:** We have one place to manage the data, making it easier to update and maintain.
3.  **Improve Code Readability:** Components can directly access the data they need, making the code easier to understand.

**Key Concepts:**

Let's break down the key concepts of Context Provider:

*   **Context:** Think of this as the "bulletin board" itself. It holds the data we want to share.
*   **Provider:** This is the component that "pins" the data to the context. It makes the data available to all its child components.
*   **Consumer (or `useContext` hook):** This is how components "read" the data from the context. They subscribe to the context and get notified whenever the data changes.

**How do we use the Context Provider?**

Let's say we want to display the currently logged-in user's name in the header. We'd do the following:

1.  **Create a Context:** We create a `ContextData` object using `createContext`. This is our bulletin board.
2.  **Create a Provider:**  We wrap our entire application (or a large part of it) with the `ContextData.Provider`. This is like putting the bulletin board up in a central location.
3.  **Provide the User Data:** Inside the `Provider`, we set the `value` prop to the user data. This is like pinning the user's name and profile picture to the bulletin board.
4.  **Consume the Data:** In the header component, we use the `useContext` hook to access the user data from the `ContextData`. This is like a component walking up to the bulletin board and reading the user's name.

Here's a simplified example of how to use Context Provider (using snippets from `src\providers\provider.js` and `src\components\Header.js`):

First, in `src\providers\provider.js`, we create our Context and Provider:

```javascript
import { createContext, useState, useEffect } from "react";

export const ContextData = createContext(null);

export const Provider = ({ children }) => {
    const [user, setData] = useState(null); // store user in state

    //...fetch user details
    return (
        <ContextData.Provider value={{ user }}>
            {children}
        </ContextData.Provider>
    );
};
```

Explanation:

* We import `createContext` and `useState` from React.
* We create a context called `ContextData`. It's initially `null` before we provide data to it.
* We create a `Provider` component that wraps our app. This is what makes the data available.
* We use `useState` to store the `user` data. This will be the current user.
* MOST IMPORTANTLY: We pass the `user` state variable as the `value` prop to `ContextData.Provider`. This "pins" the user data to the context, making it accessible to all child components wrapped by provider. `children` prop represent children components which will share the state.

Now, in `src\components\Header.js`, we use the `useContext` hook to access the user data:

```javascript
import { useContext } from "react";
import { ContextData } from "@/providers/provider";

const Header = () => {
    const { user } = useContext(ContextData);

    return (
        <header>
            {user ? <p>Welcome, {user.firstName}!</p> : <p>Please log in</p>}
        </header>
    );
};
```

Explanation:

*   We import `useContext` and our `ContextData`.
*   We call `useContext(ContextData)` to get the value that was provided by the `ContextData.Provider`. In our case, it's the `user` object.
*   Now we can access the user's `firstName` directly! If a user has logged in and has name "Alice", it will display "Welcome, Alice!".

That's it!  The `Header` component now has access to the current user's information without having to receive it as a prop. You can do this in other components as well!

**Internal Implementation:**

Let's see what happens under the hood when a component uses the `useContext` hook:

```mermaid
sequenceDiagram
    participant Component
    participant ContextData
    participant Provider

    Component->>ContextData: useContext(ContextData)
    ContextData->>Provider: Requests current value
    Provider-->>ContextData: Returns user data
    ContextData-->>Component: Returns user data
    Component->>Component: Renders with user data
```

1.  **Component calls useContext:** The component calls `useContext(ContextData)` to access the data.
2.  **ContextData requests from Provider:** The `useContext` hook internally asks the `Provider` for the current value of the context.
3.  **Provider returns data:** The `Provider` returns the user data that it's currently holding in its state.
4.  **Component receives data:** The `useContext` hook returns the user data to the component.
5.  **Component renders:** The component re-renders with the new user data.

Looking at the actual code (again from `src\providers\provider.js`), here's what's happening behind the scenes:

```javascript
export const Provider = ({ children }) => {
    const [user, setData] = useState(null);

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return (
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    );
};
```

Explanation:

*   The `Provider` component fetches the current user's details.
*   The `fetchCurrentUserDetails` API call uses API Route Handler you learned in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   The `value` prop of `ContextData.Provider` is an object containing the `user` data, as well as the `fetchCurrentUserDetails` function which components can use to update the user details globally.

The files `src\app\(root)\page.js` ,`src\app\(root)\find-friends\page.js`, `src\app\(root)\[id]\page.js` and `src\components\PostDisplay.js` all use `useContext` hook to read user and `fetchCurrentUserDetails` states, so they can access user name, profile and update information.

**Conclusion:**

In this chapter, we learned about Context Provider (ContextData). We saw how it helps us share data across different components without prop drilling, centralizing data management, and improving code readability. We explored the key concepts of context, provider, and consumer, and saw how they work together.

In the next chapter, we'll learn about the [Avatar Component](06_avatar_component.md), which displays user profile pictures.

2025-05-30 19:09:12,712 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "Avatar Component". This is Chapter 6.

Concept Details:
- Name: Avatar Component
- Description:
A reusable UI component to display user profile pictures. It abstracts away the complexity of image loading and provides a consistent look and feel throughout the application.  It also handles navigation to the user's profile page when clicked. It's like a standardized frame for displaying user photos.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

---
# Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.

---
# Chapter 4: Post Data Model

Welcome back! In [Chapter 3: API Route Handlers](03_api_route_handlers.md), we learned how to handle requests to create, update, and delete data. But what *is* that data we're working with when it comes to posts? That's where the **Post Data Model** comes in!

Imagine you're scrolling through your LinkedIn feed. Every post you see has some text, maybe an image, the user who posted it, and some likes and comments. The Post Data Model is like a template that defines what information each post contains and how it's organized.

Think of it like this: if the User Data Model (which you learned about in [Chapter 2: User Data Model](02_user_data_model.md)) is a blueprint for how to store user information, the Post Data Model is a blueprint for how to store post information!

**Why do we need a Post Data Model?**

Just like we needed a User Data Model to keep user data organized, we need a Post Data Model to keep post data organized. Without it, our application wouldn't know what to expect from each post, and it would be difficult to display and manage posts correctly.

Specifically, the Post Data Model ensures:

1.  **Consistency:** Every post has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a post.
3.  **Structure:** We know exactly where to find each piece of information for every post.

**Key Concepts:**

Let's break down what makes up our Post Data Model. It defines the properties (or attributes) of a post.

*   **Properties:** These are the individual pieces of information we store about each post. Examples include:

    *   `description`: The text content of the post (e.g., "Excited to share this article!").
    *   `image`: A link to an image in the post (if any).
    *   `userId`: The ID of the user who created the post. This links the post back to the user.
    *   `like`: An array containing the IDs of users who liked the post.
    *   `comment`: An array of comments related to the post.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., description, image URLs).
    *   `Array`: A list of things (e.g., a list of user IDs who liked the post, a list of comments).
    *   `ObjectId`: A special type of ID used to link data between different parts of our database (e.g., linking a post to a user).

**How do we use the Post Data Model?**

Let's say we want to create a new post in our application. We'd use the Post Data Model as a template. We'd provide the necessary information (description, image URL, user ID), and our application would create a new post object based on the model.

Here's a simplified example (conceptually):

```javascript
const newPost = {
  description: "Check out my new project!",
  image: "https://example.com/image.jpg",
  userId: "654321abcdef0123456789" // The ID of the user who created the post
};
```

This `newPost` object now has the structure defined by our Post Data Model.

**Internal Implementation:**

Let's take a peek under the hood! When a user creates a new post, here's what happens:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/create)
    participant Post Data Model
    participant Database

    User->>Client-side App: Creates a new post
    Client-side App->>API Route (/api/post/create): Sends post data (description, image, userId)
    API Route (/api/post/create)->>Post Data Model: Creates a new post object based on model
    Post Data Model->>Database: Saves the new post object
    Database-->>API Route (/api/post/create): Returns success or error
    API Route (/api/post/create)-->>Client-side App: Returns success or error
    Client-side App->>User: Displays the new post
```

1.  **User Input:** The user creates a new post in the Client-side App.
2.  **API Request:** The Client-side App sends the post data to the `/api/post/create` route.
3.  **Model Creation:** The `/api/post/create` route uses the Post Data Model as a blueprint to create a new post object.
4.  **Database Save:** The new post object is saved to the database.

Now, let's look at the actual code in `src\models\postModel.js`:

```javascript
import mongoose from 'mongoose'

const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : mongoose.Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    }
},{
    timestamps : true
})

const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel
```

Let's break it down:

*   `mongoose.Schema({...})`: This defines the structure of our post data.
*   `description : { type : String, default : "" }`: This says the `description` property must be a string, and if no description is provided, it defaults to an empty string.
*   `userId : { type : mongoose.Schema.Types.ObjectId, required : true, ref : 'users' }`: This says the `userId` property must be a special `ObjectId` that links to a user in the `users` collection.  `required : true` means a post can't be created without a user ID. `ref : 'users'` means this ID refers to a document in the `users` collection.
*   `timestamps: true`: This option lets the database automatically create `createdAt` and `updatedAt` fields.

```javascript
    like : {
         type : Array,
         default : []
    }
```

This snippet creates an Array which contains the list of users who "liked" the post.

The code from [API Route Handlers](03_api_route_handlers.md) which likes a post uses this model!

**Conclusion:**

In this chapter, we learned about the Post Data Model. We saw how it acts as a blueprint for post data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and how they're used to represent a post in our application.

Next, we'll explore the [Context Provider (ContextData)](05_context_provider__contextdata_.md), which helps us share data across different parts of our application.

---
# Chapter 5: Context Provider (ContextData)

Welcome back! In [Chapter 4: Post Data Model](04_post_data_model.md), we learned how to structure post data in our LinkedIn clone. But what if we want to show the currently logged-in user's name and profile picture in multiple places on the page, like the header and the post upload section? We *could* pass the user data as props to each component, but that can get messy and repetitive! That's where the **Context Provider (ContextData)** comes to the rescue!

Think of ContextData like a central bulletin board where you can pin important information that many different components need to access. In our case, that information is the currently logged-in user. Any component that needs the user's information can simply "read" it from the ContextData, without having to receive it directly as a prop from its parent.

**Why do we need a Context Provider?**

Imagine you're building a house. You could run individual electrical wires from the power source to each light fixture, but that's inefficient. Instead, you use a central electrical panel to distribute power to all the rooms. Context Provider is like that electrical panel  it provides a central place to manage and share data across your application.

Specifically, Context Provider helps us:

1.  **Avoid Prop Drilling:** We don't have to pass data through multiple layers of components that don't actually need it.
2.  **Centralize Data:** We have one place to manage the data, making it easier to update and maintain.
3.  **Improve Code Readability:** Components can directly access the data they need, making the code easier to understand.

**Key Concepts:**

Let's break down the key concepts of Context Provider:

*   **Context:** Think of this as the "bulletin board" itself. It holds the data we want to share.
*   **Provider:** This is the component that "pins" the data to the context. It makes the data available to all its child components.
*   **Consumer (or `useContext` hook):** This is how components "read" the data from the context. They subscribe to the context and get notified whenever the data changes.

**How do we use the Context Provider?**

Let's say we want to display the currently logged-in user's name in the header. We'd do the following:

1.  **Create a Context:** We create a `ContextData` object using `createContext`. This is our bulletin board.
2.  **Create a Provider:**  We wrap our entire application (or a large part of it) with the `ContextData.Provider`. This is like putting the bulletin board up in a central location.
3.  **Provide the User Data:** Inside the `Provider`, we set the `value` prop to the user data. This is like pinning the user's name and profile picture to the bulletin board.
4.  **Consume the Data:** In the header component, we use the `useContext` hook to access the user data from the `ContextData`. This is like a component walking up to the bulletin board and reading the user's name.

Here's a simplified example of how to use Context Provider (using snippets from `src\providers\provider.js` and `src\components\Header.js`):

First, in `src\providers\provider.js`, we create our Context and Provider:

```javascript
import { createContext, useState, useEffect } from "react";

export const ContextData = createContext(null);

export const Provider = ({ children }) => {
    const [user, setData] = useState(null); // store user in state

    //...fetch user details
    return (
        <ContextData.Provider value={{ user }}>
            {children}
        </ContextData.Provider>
    );
};
```

Explanation:

* We import `createContext` and `useState` from React.
* We create a context called `ContextData`. It's initially `null` before we provide data to it.
* We create a `Provider` component that wraps our app. This is what makes the data available.
* We use `useState` to store the `user` data. This will be the current user.
* MOST IMPORTANTLY: We pass the `user` state variable as the `value` prop to `ContextData.Provider`. This "pins" the user data to the context, making it accessible to all child components wrapped by provider. `children` prop represent children components which will share the state.

Now, in `src\components\Header.js`, we use the `useContext` hook to access the user data:

```javascript
import { useContext } from "react";
import { ContextData } from "@/providers/provider";

const Header = () => {
    const { user } = useContext(ContextData);

    return (
        <header>
            {user ? <p>Welcome, {user.firstName}!</p> : <p>Please log in</p>}
        </header>
    );
};
```

Explanation:

*   We import `useContext` and our `ContextData`.
*   We call `useContext(ContextData)` to get the value that was provided by the `ContextData.Provider`. In our case, it's the `user` object.
*   Now we can access the user's `firstName` directly! If a user has logged in and has name "Alice", it will display "Welcome, Alice!".

That's it!  The `Header` component now has access to the current user's information without having to receive it as a prop. You can do this in other components as well!

**Internal Implementation:**

Let's see what happens under the hood when a component uses the `useContext` hook:

```mermaid
sequenceDiagram
    participant Component
    participant ContextData
    participant Provider

    Component->>ContextData: useContext(ContextData)
    ContextData->>Provider: Requests current value
    Provider-->>ContextData: Returns user data
    ContextData-->>Component: Returns user data
    Component->>Component: Renders with user data
```

1.  **Component calls useContext:** The component calls `useContext(ContextData)` to access the data.
2.  **ContextData requests from Provider:** The `useContext` hook internally asks the `Provider` for the current value of the context.
3.  **Provider returns data:** The `Provider` returns the user data that it's currently holding in its state.
4.  **Component receives data:** The `useContext` hook returns the user data to the component.
5.  **Component renders:** The component re-renders with the new user data.

Looking at the actual code (again from `src\providers\provider.js`), here's what's happening behind the scenes:

```javascript
export const Provider = ({ children }) => {
    const [user, setData] = useState(null);

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return (
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    );
};
```

Explanation:

*   The `Provider` component fetches the current user's details.
*   The `fetchCurrentUserDetails` API call uses API Route Handler you learned in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   The `value` prop of `ContextData.Provider` is an object containing the `user` data, as well as the `fetchCurrentUserDetails` function which components can use to update the user details globally.

The files `src\app\(root)\page.js` ,`src\app\(root)\find-friends\page.js`, `src\app\(root)\[id]\page.js` and `src\components\PostDisplay.js` all use `useContext` hook to read user and `fetchCurrentUserDetails` states, so they can access user name, profile and update information.

**Conclusion:**

In this chapter, we learned about Context Provider (ContextData). We saw how it helps us share data across different components without prop drilling, centralizing data management, and improving code readability. We explored the key concepts of context, provider, and consumer, and saw how they work together.

In the next chapter, we'll learn about the [Avatar Component](06_avatar_component.md), which displays user profile pictures.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\app\(root)\page.js ---
'use client'
import ProfileCard from "@/components/ProfileCard";
import UploadPost from "@/components/UploadPost";
import { ContextData } from "@/providers/provider";
import { useContext, useEffect, useState } from "react";
import axios from 'axios'
import PostDisplay from "@/components/PostDisplay";
import Avatar from "@/components/Avatar";
import Divider from "@/components/Divider";
import handleAddRemoveFriends from "@/helpers/handleAddRemoveFriends";
import toast from 'react-hot-toast'
import News from "@/components/News";

export default function Home() {
  const {user, fetchCurrentUserDetails} = useContext(ContextData)
  const [postData,setPostData] = useState([])
  const [friendsList,setFriendsList] = useState([])

  const fetchPost = async()=>{
    const response = await axios.get("/api/post")
    setPostData(response.data.data || [])
  }

  const fetchFriendsList = async()=>{
    const response = await axios.get('/api/friends')
    setFriendsList(response.data.data)
  }

  useEffect(()=>{
    fetchPost()
    fetchFriendsList()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchFriendsList()
    toast(response.message)
  }

  return (
   <div className="container mx-auto p-4 lg:grid grid-cols-[280px,1fr,280px] gap-7 h-full items-start">
        {/*** current user profile*/}
        <section className="bg-white rounded p-2 lg:sticky lg:top-20">
          <ProfileCard
            _id={user?._id}
            profile_pic={user?.profile_pic}
            firstName={user?.firstName || ''}
            lastName={user?.lastName || ''}
            location={user?.location || ''}
            occupation={user?.occupation || ''}
            friends = {user?.friends || []}
          />
          <hr className="m-3"/>
          <h1 className="font-bold mb-3">Your Connections:</h1>
            <div>
              {
                friendsList.map((friend,index)=>{
                  return(
                    <div key={friend?._id}>
                      <div className="flex items-center gap-3 justify-between">
                        <div className="flex items-center gap-3">
                          <Avatar
                            userId={friend._id}
                            width={40}
                            height={40}
                            imageURL={friend?.profile_pic}
                          />
                          <div>
                            <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                            <p className="text-xs">{friend.occupation}</p>
                          </div>
                        </div>
                        <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                      </div>
                      <Divider/>
                    </div>
                  )
                })
              }
            </div>
        </section>


        {/*** upload post and see post*/}
        <section className="rounded mt-5 lg:mt-0">
            <UploadPost
               _id={user?._id}
               profile_pic={user?.profile_pic}
               callApi={fetchPost}
            />

            <div>
                {
                  postData.map((post,index)=>{
                    return(
                      <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                    )
                  })
                }
            </div>

        </section>


         {/*** ads and friend list*/}
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
            <div className="flex flex-row">
            <News/>
            </div>
        </section>
   </div>
  );
}

--- File: src\app\(root)\find-friends\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import { ContextData } from '@/providers/provider'
import toast from 'react-hot-toast'

const FindFriends = () => {
  const [allUser,setAllUser] = useState([])
  const {user, fetchCurrentUserDetails} = useContext(ContextData)

  const fetchAllUser = async()=>{
    const response = await axios.get("/api/all-users")
    const friendList = user?.friends || []
    const removeFriends = response.data.data.filter(userDetails => !friendList.includes(userDetails?._id))
    const removeCurrentUser = removeFriends.filter(userDetails => userDetails?._id !== user?._id) 
    setAllUser(removeCurrentUser)
  }

  useEffect(()=>{
    fetchAllUser()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchAllUser()
    toast(response.message)
  }
  return (
    <div className='container mx-auto p-4'>

        <h3 className='font-semibold text-lg mb-3'>Find <span className='text-orange-500 font-extrabold'>New</span> Friends</h3>
        <div className='flex flex-wrap gap-4'>
          {
              allUser.map((user,index)=>{
                return(
                  <div key={index} className='bg-white p-4 flex justify-center flex-col items-center gap-1 min-w-[180px] min-h-[180px]'>
                      <Avatar
                        userId={user?._id}
                        imageURL={user?.profile_pic}
                        width={60}
                        height={60}
                      />
                      <p className='text-lg font-medium capitalize my-0'>{user.firstName} {user.lastName}</p>
                      <p className='text-xs my-0 -mt-2'>{user.occupation}</p>
                      <button className='bg-blue-800 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm mt-2' onClick={()=>handleAddFriend(user?._id)}>Add Friend</button>
                  </div>
                )
              })
          }
        </div>

    </div>
  )
}

export default FindFriends

--- File: src\app\(root)\[id]\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import { ContextData } from '@/providers/provider'
import PostDisplay from '@/components/PostDisplay'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import Divider from '@/components/Divider'

const UserProfileDetails = ({ params }) => {
    const [data,setData] = useState(null)
    const [friendslist,setFirendsList] = useState([])
    const [postData,setPostData] = useState([])
    const {user, fetchCurrentUserDetails} = useContext(ContextData)
    const [loading,setLoading] = useState(false)
    
    const fetchUserDetails  = async()=>{
      const payload  = {
        userId : params.id
      }
      setLoading(true)
      const response  = await axios.post("/api/user-details",payload)

      setData(response.data.data)
      setFirendsList(response.data.friends)
      setPostData(response.data.post)
      setLoading(false)
    }

    const handleAddFriend = async(friendId)=>{
      const response = await handleAddRemoveFriends(friendId)
      fetchUserDetails()
    }

    useEffect(()=>{
      fetchUserDetails()
    },[])

    const isDisplayAddFriend = user?.friends?.includes(data?._id) || user?._id === data?._id
  return (
    <div className='container mx-auto'>

        <div className='mt-5 grid gap-10 lg:grid-cols-[2fr,1fr] items-start'>
            {/**user information and post */}
            <div className=''>
                {/**user information */}
                <div className='bg-white p-4'>
                      <div className='h-36 bg-slate-200 rounded mb-14'>
                          <div className='bg-white h-36 w-36 rounded-full translate-x-8 translate-y-1/3 p-1 flex justify-center items-center'>
                              <Avatar
                                imageURL={data?.profile_pic}
                                userId={data?._id}
                                width={130}
                                height={130}
                              />
                          </div>
                      </div>
                      <p className='font-bold text-lg lg:text-2xl capitalize'>{data?.firstName} {data?.lastName}</p>
                      <p className='text-base lg:text-lg'>{data?.occupation}</p>

                      {
                        !isDisplayAddFriend && (
                          <button className='bg-blue-800 hover:bg-blue-700 text-white font-semibold px-5 rounded-full my-3 py-2'>Add Friend</button>
                        )
                      }
                </div>

                {/***post */}
                    <div className='w-full'>
                    {
                      postData.map((post,index)=>{
                        return(
                          <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                        )
                      })
                    }
                  </div> 
            </div>
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
              
              <h1 className="font-bold mb-3">Friends List:</h1>
              <div>
                {
                  friendslist.map((friend,index)=>{
                    return(
                      <div key={friend?._id}>
                        <div className="flex items-center gap-3 justify-between">
                          <div className="flex items-center gap-3">
                              <Avatar
                                userId={friend._id}
                                width={40}
                                height={40}
                                imageURL={friend?.profile_pic}
                              />
                              <div>
                                <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                                <p className="text-xs">{friend.occupation}</p>
                              </div>
                          </div>
                          <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                        </div>

                        <Divider/>
                      </div>
                    )
                  })
                }
              </div>
  
          </section>


        </div>


        {
          loading && (
            <div className='fixed top-0 bottom-0 right-0 left-0 bg-slate-500 bg-opacity-25 flex justify-center items-center'>
              <p className='bg-white px-6 py-2 text-lg'>Loading...</p>
            </div>
          )
        }
    </div>
  )
}

export default UserProfileDetails

--- File: src\components\Avatar.js ---
import React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar

--- File: src\components\Header.js ---
'use client'
import React, { useContext, useState } from 'react'
import Image from 'next/image'
import { headerNavLink } from '@/constants'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import axios from 'axios'
import toast from 'react-hot-toast'
import { useRouter } from 'next/navigation'
import { ContextData } from '@/providers/provider'
import Avatar from './Avatar'
import { Search } from 'lucide-react'

const Header = () => {
    const path = usePathname()
    const router = useRouter()
    const [openUserMenu, setOpenUserMenu] = useState(false)
    const { user, fetchCurrentUserDetails } = useContext(ContextData)

    const handleOpenClose = () => {
        setOpenUserMenu((prev) => !prev)
    }

    const handleUserLogout = async () => {
        const response = await axios.get('/api/logout')
        setOpenUserMenu(false)
        toast(response?.data.message)
        router.push("/login")
    }

    return (
        <header className='h-16 bg-white sticky z-40 shadow top-0'>
            <div className='container mx-auto h-full flex items-center px-4 justify-between'>
                <div className='grid grid-cols-[170px,1fr] items-center'>
                    <Link href={"/"}>
                        <Image 
                            src={'/logo.png'}
                            width={190}
                            height={70}
                            alt='logo'
                        />
                    </Link>

                    {/* Search input */}
                    <div className='w-full items-center gap-2 border bg-slate-100 px-1 rounded hidden lg:flex'>
                        <input 
                            type='text' 
                            placeholder='Search here...'
                            className='w-full max-w-52 bg-slate-100 py-1 px-2 outline-none'
                        />
                        <Search />
                    </div>
                </div>

                <div className='flex items-center gap-10 h-full'>
                    {/* Navbar */}
                    <nav className='hidden lg:flex items-center gap-4 h-full'>
                        {headerNavLink.map((navlink, index) => { 
                            const isActive = path === navlink.route
                            const Icon = navlink.icon
                            return (
                                <Link 
                                    href={navlink.route}
                                    key={index}
                                    className={`flex flex-col justify-center items-center gap-1 h-full px-4 ${isActive ? 'bg-slate-100' : ''}`}
                                >
                                    <Icon />
                                    <p className='text-sm'>{navlink.label}</p>
                                </Link>
                            )
                        })}
                    </nav>

                    <div>
                        {/* Current user login image */}
                        <div className='flex flex-col justify-center items-center cursor-pointer relative'>
                            <div onClick={handleOpenClose} className='flex flex-col justify-center items-center'>
                                <Avatar
                                    userId={user?._id}
                                    imageURL={user?.profile_pic}
                                    width={28}
                                    height={28}
                                    disable={true}
                                />
                                <p className='text-sm'>Me</p>
                            </div>
                            
                            {/* User menu */}
                            {openUserMenu && (
                                <div className='shadow absolute top-14 right-0 min-w-60 p-4 rounded bg-white'>
                                    <div className='font-semibold text-center flex flex-col justify-center items-center'>
                                        <Avatar
                                            userId={user?._id}
                                            imageURL={user?.profile_pic}
                                            width={45}
                                            height={45}
                                            extraWidth={20}
                                            extraHeight={20}
                                        />
                                        <p className='text-lg'>
                                            { user?.firstName + " " + user?.lastName }
                                        </p>
                                        <p className='text-sm'>
                                            {user?.occupation}
                                        </p>
                                    </div>

                                    <div className='p-[0.5px] my-1 bg-slate-200'></div>

                                    {/* Mobile responsive */}
                                    <nav className='flex lg:hidden justify-center flex-col gap-2 h-full'>
                                        {headerNavLink.map((navlink, index) => { 
                                            const isActive = path === navlink.route
                                            const Icon = navlink.icon
                                            return (
                                                <Link 
                                                    href={navlink.route}
                                                    key={index}
                                                    className={`flex flex-row gap-2 h-full px-4 py-3 ${isActive ? 'bg-slate-100' : ''}`}
                                                    onClick={handleOpenClose}
                                                >
                                                    <Icon />
                                                    <p className='text-sm'>{navlink.label}</p>
                                                </Link>
                                            )
                                        })}
                                    </nav>

                                    <button className='bg-red-600 text-white rounded hover:bg-red-700 w-full py-1' onClick={handleUserLogout}>Logout</button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            </div>
        </header>
    )
}

export default Header


--- File: src\components\PostDisplay.js ---
import React, { useContext, useEffect, useState } from 'react'
import Avatar from './Avatar'
import Image from 'next/image'
import { ContextData } from '@/providers/provider'
import axios from 'axios'
import { MessageSquare, Share, UserPlus } from 'lucide-react'

const PostDisplay = ({ data ,handleAddFriend }) => {
    const [likeData,setLikeData] = useState(data?.like || [])
    const [commentData,setCommentData] = useState(data?.comment || [])
    const [openComment,setOpenComment] = useState(false)
    const [comment,setComment] = useState('')

    const {user, fetchCurrentUserDetails} = useContext(ContextData)


    const handleLikePost = async()=>{
        const payload = {
            _id : data?._id
        }
        const response = await axios.post('/api/post/like',payload)

        setLikeData(response.data.data)
    }


    const handleOpenCloseComment = () =>{
        setOpenComment(preve => !preve)
    }

    const fetchCommentData = async() =>{
        const payload  = {
            postId : data?._id
        }
        const response = await axios.post("api/post/get-comment-for-post",payload)

        setCommentData(response.data.data.comment || [])
    }

    useEffect(()=>{
        if(openComment){
            fetchCommentData()
        }
    },[])


    const handleuploadComment = async() =>{
        const payload = {
            description : comment,
            postId : data?._id
        }
        if(comment){
            const response  = await axios.post("api/post/comment",payload)
            setComment('')
            fetchCommentData()
        }
        
    }
    


    const currentUserLiked = likeData.includes(user?._id)
    const isDisplayAddFriend = user?.friends?.includes(data?.userId?._id) || user?._id === data?.userId?._id
  return (
    <div className='bg-white p-4 my-6'>
        <div className='flex gap-3 items-center justify-between'>
            <div className='flex gap-3 items-center'>
                <Avatar
                    userId={data.userId._id}
                    imageURL={data.userId.profile_pic}
                    width={40}
                    height={40}
                />
                <div>
                    <p className='font-bold'>{data.userId.firstName} {data.userId.lastName}</p>
                    <p className='text-xs'>{data.userId.occupation}</p>
                </div>
            </div>

            {
                !isDisplayAddFriend && (
                    <div className='bg-white shadow-md p-2 rounded-full flex justify-center items-center cursor-pointer hover:bg-blue-700' onClick={()=>handleAddFriend(data?.userId?._id)}>
                        <UserPlus/>
                    </div>
                )
            }
           
        </div>

        <p className='py-3'>
            {data.description}
        </p>

        <div className='w-full h-full'>
            {
                data.image && (
                    <Image 
                        src={data.image}
                        width={1000}
                        height={1000}
                        alt='post'
                    />
                )
            }
        </div>


        <div className='text-sm flex items-center justify-between mt-3'>
             {/**like count */}
            <div>
                {likeData.length  === 0 ? "You're first to like" : likeData.length + " Likes"  }
            </div>

            {/**comment count */}
            <div>
                {commentData.length} comment
            </div>

        </div>

        <div className='p-[0.5px] bg-slate-200'></div>

        
        <div className='py-1 flex justify-between gap-3'>
             {/**like */}
             <div className='flex items-center gap-1 cursor-pointer' onClick={handleLikePost}>
                {
                    currentUserLiked ? (
                        <Image
                            src={'/liked.svg'}
                            width={20}
                            height={20}
                            alt='like' 
                        />
                    ) : (
                        <Image
                        src={'/like.svg'}
                        width={20}
                        height={20}
                        alt='like' 
                        />
                    )
                }
                
                <p  className={currentUserLiked && 'text-blue-800 font-semibold'}>Like</p>
             </div>


              {/**comment */}
              <div className='flex items-center gap-1 cursor-pointer hover:text-blue-700' onClick={handleOpenCloseComment}>
                    <MessageSquare/>
                    <p>Comment</p>  
              </div>


            {/**share */}
            <div>
                <div className='flex items-center gap-1 cursor-pointer'>
                <Share/>
                <p>Share</p> 
                </div>
            </div>
        </div>


        {/****display all the comment */}
        {
            openComment && (
                <div className='p-4 bg-white w-full'>
                     <div className='flex items-center gap-4 w-full'>
                        <Avatar
                            userId={user._id}
                            imageURL={user.profile_pic}
                            width={40}
                            height={40}
                            alt={user.firstName}
                        />
                        <div className='w-full flex gap-1'>
                            <input 
                                type='text' 
                                placeholder='type comment here...' 
                                className='bg-slate-100 rounded-full px-4 py-2 w-full outline-none' 
                                onChange={(e)=>setComment(e.target.value)}
                                value={comment}
                            />
                            <button className='bg-blue-700 text-white text-sm px-3 py-1 rounded-full' onClick={handleuploadComment}>Send</button>
                        </div>
                    </div>


                    {/**list of comment */}
                    <div className='mt-3'>
                        {
                            commentData.map((comment,index)=>{
                                return(
                                    <div className='ml-5 p-2 border-b' key={comment?._id}>
                                        <div className='flex gap-3 items-center'>
                                            <Avatar
                                                userId={comment?.userId?._id}
                                                imageURL={comment?.userId?.profile_pic}
                                                width={30}
                                                height={30}
                                                alt={comment?.userId?.firstName}
                                            />
                                            <div className='flex flex-col'>
                                                <p className='font-semibold text-sm'>{comment?.userId?.firstName} {comment?.userId?.lastName}</p>
                                                <p className='text-xs -mt-1'>{comment?.userId?.occupation}</p>
                                            </div>
                                        </div> 
                                        <div className='text-sm py-1 px-2'>
                                            {comment.description}
                                        </div>   
                                    </div>
                                )
                            })
                        }
                    </div>

                    
                </div>
            )
        }
    </div>
  )
}

export default PostDisplay

--- File: src\components\ProfileCard.js ---
'use client'
import React from 'react'
import Avatar from './Avatar'
import { LucideUserPlus, MapPinIcon } from 'lucide-react'

const ProfileCard = ({_id, firstName, lastName, occupation, location, profile_pic, friends = [], profileViews = 0 , profileImpressions = 0  }) => {
  return (
    <div className='p-2'>
      {/**image  */}
        <div className='bg-slate-200 h-16 mb-10'>
            <div className='w-16 h-16 rounded-full bg-white mx-auto translate-y-8 shadow-md'>
                <Avatar
                    userId={_id}
                    imageURL={profile_pic}
                    width={64}
                    height={64}
                />
            </div>
        </div>

        {/**name and occupation */}
        <div className='text-center'>
            <p className='font-bold text-lg'>{firstName +" "+lastName}</p> 
            <p className='text-sm'>{occupation}</p>
        </div>

        <div className='p-[0.5px] bg-slate-200 my-2'></div>

          {/**name and friends */}
         <div className='grid gap-1'>
              <div className='flex items-center gap-3'>
                <MapPinIcon/>
                <p>{location}</p>
              </div>
              <div  className='flex items-center gap-3'>
                <LucideUserPlus/>
                <p >Friends <span className='text-xs'>({friends.length})</span></p>
              </div>
         </div>


         <div className='p-[0.5px] bg-slate-200 my-2'></div>

        {/****profile views and profile impresss */}
        <div className='grid gap-1'>
            <div className='flex justify-between items-center gap-3'>
                <p>Profile views</p>
                <p>{profileViews}</p>
            </div>

            <div className='flex justify-between items-center gap-3'>
                <p>Profile impressions</p>
                <p>{profileImpressions}</p>
            </div>

        </div>

     
    </div>
  )
}

export default ProfileCard

--- File: src\components\UploadPost.js ---
'use client'
import React, { useRef, useState } from 'react'
import Avatar from './Avatar'
import Divider from './Divider'
import toast from 'react-hot-toast'
import axios from 'axios'
import { CrossIcon, ImageIcon } from 'lucide-react'

const UploadPost = ({ _id, profile_pic,callApi }) => {
    const [data, setData] = useState({
        description: "",
        image: ""
    })
    const inputFileRef = useRef()
    const [loading,setLoading] = useState(false)

    const handleOpenFileExplore = () =>{
        inputFileRef.current.click()
    }

    const handleOnChange = (e) => {
        const { value, name } = e.target

        setData((preve) => {
            return {
                ...preve,
                [name]: value
            }
        })
    }

    const handleUploadFile = (e)=>{
        const file = e.target.files[0]

        setData((preve)=>{
            return{
                ...preve,
                image : file
            }
        })
    }
    const handleClearUpload = (e)=>{
        setData((preve)=>{
            return{
                ...preve,
                image : ""
            }
        })
    }

    const handlePost = async(e)=>{
        e.preventDefault()

        if(!data.description){
            toast("Please type something....")
            return
        }

        const formData = new FormData()
        formData.set("description",data.description)
        formData.set("image",data.image)
        setLoading(true)
        const response = await axios.post('/api/upload-post',formData)
        setLoading(false)
        toast(response.data.message)
        if(response.data.success){
            setData({
                description: "",
                image: ""
            })
            callApi()
        }


    }

    return (
        <div className='bg-white p-4 rounded'>
            <div className='flex gap-4 items-start'>
                <Avatar
                    imageURL={profile_pic}
                    width={50}
                    height={50}
                    userId={_id}
                />

                <div className='w-full'>
                    <textarea
                        name='description'
                        placeholder='type here...'
                        className='bg-slate-100 px-4 py-2 w-full outline-none rounded resize-none'
                        value={data.description}
                        onChange={handleOnChange}
                    />
                    {
                        data?.image && (
                            <div className='bg-slate-100 border text-center relative py-2 px-4'>
                                <div className='w-5 h-5 text-sm hover:text-red-600 cursor-pointer rounded-full absolute right-0 top-0' onClick={handleClearUpload}>
                                    <CrossIcon/>
                                </div>
                                {data?.image?.name}
                            </div>
                        )
                    }
                    
                </div>
            </div>



            <Divider />

            <div className='flex justify-between items-center'>
                <div className='flex items-center gap-2 cursor-pointer' onClick={handleOpenFileExplore}>
                    <ImageIcon/>
                    <p className='hover:text-blue-700'>Image</p>

                    <input type='file' className='hidden' ref={inputFileRef} onChange={handleUploadFile}/>
                </div>

                <button className='bg-blue-700 px-5 py-1 text-white rounded-full' onClick={handlePost}>Post</button>
            </div>



            {/***loading state */}
            {
                loading && (
                <div className='fixed bg-slate-200 bg-opacity-60 top-0 right-0 left-0 bottom-0 w-full h-full flex justify-center items-center'>
                    <p className='bg-white p-4'>Loading....</p>
                </div>
                )
            }
            
        </div>
    )
}

export default UploadPost

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 6: Avatar Component`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,779 - INFO - RESPONSE (from cache): # Chapter 6: Avatar Component

Welcome back! In [Chapter 5: Context Provider (ContextData)](05_context_provider__contextdata_.md), we learned how to share user data across different components. Now, let's say we want to display user profile pictures in various places, like the header, post sections, and friend lists. We want a consistent look and feel everywhere, and we want to make it easy to navigate to the user's profile when you click the picture. This is where the **Avatar Component** comes in handy!

Think of the Avatar Component as a standardized frame for displaying user profile photos. It takes the user's profile picture URL and renders it within a consistent, circular frame. It also handles navigation to the user's profile page when you click on it. It's like having a reusable photo frame that you can put anywhere in your app!

**Why do we need an Avatar Component?**

Without an Avatar Component, we'd have to write the same code to display a profile picture every time we needed it. We'd have to handle image loading, styling (making it circular, setting the size), and navigation separately each time. This would lead to:

1.  **Repetitive Code:** We'd be writing the same code over and over again.
2.  **Inconsistent Look and Feel:** Different profile pictures might have slightly different styles.
3.  **Maintenance Nightmare:** If we wanted to change the style of all profile pictures, we'd have to update the code in multiple places.

The Avatar component helps us solve the issues.

**Key Concepts:**

Let's break down the key concepts of the Avatar Component:

*   **Reusability:** The Avatar Component is a reusable piece of UI that can be used in multiple places throughout the application.
*   **Consistency:** It ensures that all profile pictures have a consistent look and feel.
*   **Navigation:** It handles navigation to the user's profile page when clicked.

**How do we use the Avatar Component?**

Let's say we want to display a user's profile picture in the header of our application. We'd use the Avatar Component like this (referencing `src\components\Header.js`):

```javascript
<Avatar
    userId={user?._id}
    imageURL={user?.profile_pic}
    width={28}
    height={28}
    disable={true}
/>
```

Explanation:

*   `userId`: The ID of the user whose profile picture we want to display.
*   `imageURL`: The URL of the user's profile picture.
*   `width`: The width of the avatar in pixels.
*   `height`: The height of the avatar in pixels.
*   `disable`: If `true`, the avatar won't be clickable (no navigation).

When this code runs, the Avatar Component will:

1.  Load the image from the `imageURL`.
2.  Display the image in a circular frame with the specified `width` and `height`.
3.  Make the avatar clickable, navigating to the user's profile page when clicked (unless `disable` is set to `true`).

If `imageURL` is missing, it will display a default user icon.

**Internal Implementation:**

Let's see what happens under the hood when the Avatar Component is rendered:

```mermaid
sequenceDiagram
    participant Component
    participant Avatar Component
    participant Image (or Default Icon)
    participant Link

    Component->>Avatar Component: Renders Avatar Component with imageURL and userId
    Avatar Component->>Image (or Default Icon): Checks if imageURL exists
    alt imageURL exists
        Avatar Component->>Image: Renders Image component with imageURL
    else imageURL doesn't exist
        Avatar Component->>Image: Renders Default Icon
    end
    Avatar Component->>Link: Renders Link component with href to user profile
    Link->>Component: Returns rendered Avatar with clickable link
```

1.  **Component Renders Avatar:** A component renders the Avatar Component, passing in the `imageURL` and `userId`.
2.  **Avatar Checks for Image:** The Avatar Component checks if the `imageURL` exists.
3.  **Render Image or Icon:**
    *   If the `imageURL` exists, it renders an `Image` component with the provided URL.
    *   If the `imageURL` is missing, it renders a default user icon.
4.  **Wrap in Link:**  The Avatar Component wraps the image (or icon) in a `Link` component, which makes it clickable and navigates to the user's profile page (e.g., `/user/123`).
5.  **Returns Rendered Avatar:** The Avatar Component returns the rendered avatar with the clickable link.

Now, let's look at the actual code in `src\components\Avatar.js`:

```javascript
import React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar
```

Let's break it down:

*   `imageURL`, `userId`, `width`, and `height` are props passed to the component.
*   The component uses conditional rendering (`imageURL ? ... : ...`) to display either the image or a default icon, which keeps the UI consistent.
*   If `imageURL` is exist, it uses Next.js's `Image` component to display the profile picture. `className='rounded-full'` makes the image circular.
*   `Link` is the next.js component to enable routing by wrapping the Image component.
*   `<Link href={"/"+userId}>` creates a link to the user's profile page. When `disable` is false, the link goes to that user's profile page; otherwise, it does nothing.
*   `usePathname` is a Next.js hook to get the current URL.

The [Context Provider (ContextData)](05_context_provider__contextdata_.md) chapter gives several examples of the Avatar component used to display user profile images.

**Conclusion:**

In this chapter, we learned about the Avatar Component. We saw how it helps us display user profile pictures consistently and easily throughout our application. We explored the key concepts of reusability, consistency, and navigation, and we looked at the internal implementation of the Avatar Component.

In the next chapter, we'll delve into the [Database Connection](07_database_connection.md), which handles connection and querying to DB.

2025-05-30 19:09:12,783 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "Database Connection". This is Chapter 7.

Concept Details:
- Name: Database Connection
- Description:
This abstraction handles the connection to the MongoDB database. It's like the plumber connecting your house to the city's water supply. It ensures that the application can reliably read and write data to the database.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

---
# Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.

---
# Chapter 4: Post Data Model

Welcome back! In [Chapter 3: API Route Handlers](03_api_route_handlers.md), we learned how to handle requests to create, update, and delete data. But what *is* that data we're working with when it comes to posts? That's where the **Post Data Model** comes in!

Imagine you're scrolling through your LinkedIn feed. Every post you see has some text, maybe an image, the user who posted it, and some likes and comments. The Post Data Model is like a template that defines what information each post contains and how it's organized.

Think of it like this: if the User Data Model (which you learned about in [Chapter 2: User Data Model](02_user_data_model.md)) is a blueprint for how to store user information, the Post Data Model is a blueprint for how to store post information!

**Why do we need a Post Data Model?**

Just like we needed a User Data Model to keep user data organized, we need a Post Data Model to keep post data organized. Without it, our application wouldn't know what to expect from each post, and it would be difficult to display and manage posts correctly.

Specifically, the Post Data Model ensures:

1.  **Consistency:** Every post has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a post.
3.  **Structure:** We know exactly where to find each piece of information for every post.

**Key Concepts:**

Let's break down what makes up our Post Data Model. It defines the properties (or attributes) of a post.

*   **Properties:** These are the individual pieces of information we store about each post. Examples include:

    *   `description`: The text content of the post (e.g., "Excited to share this article!").
    *   `image`: A link to an image in the post (if any).
    *   `userId`: The ID of the user who created the post. This links the post back to the user.
    *   `like`: An array containing the IDs of users who liked the post.
    *   `comment`: An array of comments related to the post.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., description, image URLs).
    *   `Array`: A list of things (e.g., a list of user IDs who liked the post, a list of comments).
    *   `ObjectId`: A special type of ID used to link data between different parts of our database (e.g., linking a post to a user).

**How do we use the Post Data Model?**

Let's say we want to create a new post in our application. We'd use the Post Data Model as a template. We'd provide the necessary information (description, image URL, user ID), and our application would create a new post object based on the model.

Here's a simplified example (conceptually):

```javascript
const newPost = {
  description: "Check out my new project!",
  image: "https://example.com/image.jpg",
  userId: "654321abcdef0123456789" // The ID of the user who created the post
};
```

This `newPost` object now has the structure defined by our Post Data Model.

**Internal Implementation:**

Let's take a peek under the hood! When a user creates a new post, here's what happens:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/create)
    participant Post Data Model
    participant Database

    User->>Client-side App: Creates a new post
    Client-side App->>API Route (/api/post/create): Sends post data (description, image, userId)
    API Route (/api/post/create)->>Post Data Model: Creates a new post object based on model
    Post Data Model->>Database: Saves the new post object
    Database-->>API Route (/api/post/create): Returns success or error
    API Route (/api/post/create)-->>Client-side App: Returns success or error
    Client-side App->>User: Displays the new post
```

1.  **User Input:** The user creates a new post in the Client-side App.
2.  **API Request:** The Client-side App sends the post data to the `/api/post/create` route.
3.  **Model Creation:** The `/api/post/create` route uses the Post Data Model as a blueprint to create a new post object.
4.  **Database Save:** The new post object is saved to the database.

Now, let's look at the actual code in `src\models\postModel.js`:

```javascript
import mongoose from 'mongoose'

const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : mongoose.Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    }
},{
    timestamps : true
})

const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel
```

Let's break it down:

*   `mongoose.Schema({...})`: This defines the structure of our post data.
*   `description : { type : String, default : "" }`: This says the `description` property must be a string, and if no description is provided, it defaults to an empty string.
*   `userId : { type : mongoose.Schema.Types.ObjectId, required : true, ref : 'users' }`: This says the `userId` property must be a special `ObjectId` that links to a user in the `users` collection.  `required : true` means a post can't be created without a user ID. `ref : 'users'` means this ID refers to a document in the `users` collection.
*   `timestamps: true`: This option lets the database automatically create `createdAt` and `updatedAt` fields.

```javascript
    like : {
         type : Array,
         default : []
    }
```

This snippet creates an Array which contains the list of users who "liked" the post.

The code from [API Route Handlers](03_api_route_handlers.md) which likes a post uses this model!

**Conclusion:**

In this chapter, we learned about the Post Data Model. We saw how it acts as a blueprint for post data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and how they're used to represent a post in our application.

Next, we'll explore the [Context Provider (ContextData)](05_context_provider__contextdata_.md), which helps us share data across different parts of our application.

---
# Chapter 5: Context Provider (ContextData)

Welcome back! In [Chapter 4: Post Data Model](04_post_data_model.md), we learned how to structure post data in our LinkedIn clone. But what if we want to show the currently logged-in user's name and profile picture in multiple places on the page, like the header and the post upload section? We *could* pass the user data as props to each component, but that can get messy and repetitive! That's where the **Context Provider (ContextData)** comes to the rescue!

Think of ContextData like a central bulletin board where you can pin important information that many different components need to access. In our case, that information is the currently logged-in user. Any component that needs the user's information can simply "read" it from the ContextData, without having to receive it directly as a prop from its parent.

**Why do we need a Context Provider?**

Imagine you're building a house. You could run individual electrical wires from the power source to each light fixture, but that's inefficient. Instead, you use a central electrical panel to distribute power to all the rooms. Context Provider is like that electrical panel  it provides a central place to manage and share data across your application.

Specifically, Context Provider helps us:

1.  **Avoid Prop Drilling:** We don't have to pass data through multiple layers of components that don't actually need it.
2.  **Centralize Data:** We have one place to manage the data, making it easier to update and maintain.
3.  **Improve Code Readability:** Components can directly access the data they need, making the code easier to understand.

**Key Concepts:**

Let's break down the key concepts of Context Provider:

*   **Context:** Think of this as the "bulletin board" itself. It holds the data we want to share.
*   **Provider:** This is the component that "pins" the data to the context. It makes the data available to all its child components.
*   **Consumer (or `useContext` hook):** This is how components "read" the data from the context. They subscribe to the context and get notified whenever the data changes.

**How do we use the Context Provider?**

Let's say we want to display the currently logged-in user's name in the header. We'd do the following:

1.  **Create a Context:** We create a `ContextData` object using `createContext`. This is our bulletin board.
2.  **Create a Provider:**  We wrap our entire application (or a large part of it) with the `ContextData.Provider`. This is like putting the bulletin board up in a central location.
3.  **Provide the User Data:** Inside the `Provider`, we set the `value` prop to the user data. This is like pinning the user's name and profile picture to the bulletin board.
4.  **Consume the Data:** In the header component, we use the `useContext` hook to access the user data from the `ContextData`. This is like a component walking up to the bulletin board and reading the user's name.

Here's a simplified example of how to use Context Provider (using snippets from `src\providers\provider.js` and `src\components\Header.js`):

First, in `src\providers\provider.js`, we create our Context and Provider:

```javascript
import { createContext, useState, useEffect } from "react";

export const ContextData = createContext(null);

export const Provider = ({ children }) => {
    const [user, setData] = useState(null); // store user in state

    //...fetch user details
    return (
        <ContextData.Provider value={{ user }}>
            {children}
        </ContextData.Provider>
    );
};
```

Explanation:

* We import `createContext` and `useState` from React.
* We create a context called `ContextData`. It's initially `null` before we provide data to it.
* We create a `Provider` component that wraps our app. This is what makes the data available.
* We use `useState` to store the `user` data. This will be the current user.
* MOST IMPORTANTLY: We pass the `user` state variable as the `value` prop to `ContextData.Provider`. This "pins" the user data to the context, making it accessible to all child components wrapped by provider. `children` prop represent children components which will share the state.

Now, in `src\components\Header.js`, we use the `useContext` hook to access the user data:

```javascript
import { useContext } from "react";
import { ContextData } from "@/providers/provider";

const Header = () => {
    const { user } = useContext(ContextData);

    return (
        <header>
            {user ? <p>Welcome, {user.firstName}!</p> : <p>Please log in</p>}
        </header>
    );
};
```

Explanation:

*   We import `useContext` and our `ContextData`.
*   We call `useContext(ContextData)` to get the value that was provided by the `ContextData.Provider`. In our case, it's the `user` object.
*   Now we can access the user's `firstName` directly! If a user has logged in and has name "Alice", it will display "Welcome, Alice!".

That's it!  The `Header` component now has access to the current user's information without having to receive it as a prop. You can do this in other components as well!

**Internal Implementation:**

Let's see what happens under the hood when a component uses the `useContext` hook:

```mermaid
sequenceDiagram
    participant Component
    participant ContextData
    participant Provider

    Component->>ContextData: useContext(ContextData)
    ContextData->>Provider: Requests current value
    Provider-->>ContextData: Returns user data
    ContextData-->>Component: Returns user data
    Component->>Component: Renders with user data
```

1.  **Component calls useContext:** The component calls `useContext(ContextData)` to access the data.
2.  **ContextData requests from Provider:** The `useContext` hook internally asks the `Provider` for the current value of the context.
3.  **Provider returns data:** The `Provider` returns the user data that it's currently holding in its state.
4.  **Component receives data:** The `useContext` hook returns the user data to the component.
5.  **Component renders:** The component re-renders with the new user data.

Looking at the actual code (again from `src\providers\provider.js`), here's what's happening behind the scenes:

```javascript
export const Provider = ({ children }) => {
    const [user, setData] = useState(null);

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return (
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    );
};
```

Explanation:

*   The `Provider` component fetches the current user's details.
*   The `fetchCurrentUserDetails` API call uses API Route Handler you learned in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   The `value` prop of `ContextData.Provider` is an object containing the `user` data, as well as the `fetchCurrentUserDetails` function which components can use to update the user details globally.

The files `src\app\(root)\page.js` ,`src\app\(root)\find-friends\page.js`, `src\app\(root)\[id]\page.js` and `src\components\PostDisplay.js` all use `useContext` hook to read user and `fetchCurrentUserDetails` states, so they can access user name, profile and update information.

**Conclusion:**

In this chapter, we learned about Context Provider (ContextData). We saw how it helps us share data across different components without prop drilling, centralizing data management, and improving code readability. We explored the key concepts of context, provider, and consumer, and saw how they work together.

In the next chapter, we'll learn about the [Avatar Component](06_avatar_component.md), which displays user profile pictures.

---
# Chapter 6: Avatar Component

Welcome back! In [Chapter 5: Context Provider (ContextData)](05_context_provider__contextdata_.md), we learned how to share user data across different components. Now, let's say we want to display user profile pictures in various places, like the header, post sections, and friend lists. We want a consistent look and feel everywhere, and we want to make it easy to navigate to the user's profile when you click the picture. This is where the **Avatar Component** comes in handy!

Think of the Avatar Component as a standardized frame for displaying user profile photos. It takes the user's profile picture URL and renders it within a consistent, circular frame. It also handles navigation to the user's profile page when you click on it. It's like having a reusable photo frame that you can put anywhere in your app!

**Why do we need an Avatar Component?**

Without an Avatar Component, we'd have to write the same code to display a profile picture every time we needed it. We'd have to handle image loading, styling (making it circular, setting the size), and navigation separately each time. This would lead to:

1.  **Repetitive Code:** We'd be writing the same code over and over again.
2.  **Inconsistent Look and Feel:** Different profile pictures might have slightly different styles.
3.  **Maintenance Nightmare:** If we wanted to change the style of all profile pictures, we'd have to update the code in multiple places.

The Avatar component helps us solve the issues.

**Key Concepts:**

Let's break down the key concepts of the Avatar Component:

*   **Reusability:** The Avatar Component is a reusable piece of UI that can be used in multiple places throughout the application.
*   **Consistency:** It ensures that all profile pictures have a consistent look and feel.
*   **Navigation:** It handles navigation to the user's profile page when clicked.

**How do we use the Avatar Component?**

Let's say we want to display a user's profile picture in the header of our application. We'd use the Avatar Component like this (referencing `src\components\Header.js`):

```javascript
<Avatar
    userId={user?._id}
    imageURL={user?.profile_pic}
    width={28}
    height={28}
    disable={true}
/>
```

Explanation:

*   `userId`: The ID of the user whose profile picture we want to display.
*   `imageURL`: The URL of the user's profile picture.
*   `width`: The width of the avatar in pixels.
*   `height`: The height of the avatar in pixels.
*   `disable`: If `true`, the avatar won't be clickable (no navigation).

When this code runs, the Avatar Component will:

1.  Load the image from the `imageURL`.
2.  Display the image in a circular frame with the specified `width` and `height`.
3.  Make the avatar clickable, navigating to the user's profile page when clicked (unless `disable` is set to `true`).

If `imageURL` is missing, it will display a default user icon.

**Internal Implementation:**

Let's see what happens under the hood when the Avatar Component is rendered:

```mermaid
sequenceDiagram
    participant Component
    participant Avatar Component
    participant Image (or Default Icon)
    participant Link

    Component->>Avatar Component: Renders Avatar Component with imageURL and userId
    Avatar Component->>Image (or Default Icon): Checks if imageURL exists
    alt imageURL exists
        Avatar Component->>Image: Renders Image component with imageURL
    else imageURL doesn't exist
        Avatar Component->>Image: Renders Default Icon
    end
    Avatar Component->>Link: Renders Link component with href to user profile
    Link->>Component: Returns rendered Avatar with clickable link
```

1.  **Component Renders Avatar:** A component renders the Avatar Component, passing in the `imageURL` and `userId`.
2.  **Avatar Checks for Image:** The Avatar Component checks if the `imageURL` exists.
3.  **Render Image or Icon:**
    *   If the `imageURL` exists, it renders an `Image` component with the provided URL.
    *   If the `imageURL` is missing, it renders a default user icon.
4.  **Wrap in Link:**  The Avatar Component wraps the image (or icon) in a `Link` component, which makes it clickable and navigates to the user's profile page (e.g., `/user/123`).
5.  **Returns Rendered Avatar:** The Avatar Component returns the rendered avatar with the clickable link.

Now, let's look at the actual code in `src\components\Avatar.js`:

```javascript
import React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar
```

Let's break it down:

*   `imageURL`, `userId`, `width`, and `height` are props passed to the component.
*   The component uses conditional rendering (`imageURL ? ... : ...`) to display either the image or a default icon, which keeps the UI consistent.
*   If `imageURL` is exist, it uses Next.js's `Image` component to display the profile picture. `className='rounded-full'` makes the image circular.
*   `Link` is the next.js component to enable routing by wrapping the Image component.
*   `<Link href={"/"+userId}>` creates a link to the user's profile page. When `disable` is false, the link goes to that user's profile page; otherwise, it does nothing.
*   `usePathname` is a Next.js hook to get the current URL.

The [Context Provider (ContextData)](05_context_provider__contextdata_.md) chapter gives several examples of the Avatar component used to display user profile images.

**Conclusion:**

In this chapter, we learned about the Avatar Component. We saw how it helps us display user profile pictures consistently and easily throughout our application. We explored the key concepts of reusability, consistency, and navigation, and we looked at the internal implementation of the Avatar Component.

In the next chapter, we'll delve into the [Database Connection](07_database_connection.md), which handles connection and querying to DB.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\database\db.js ---
import mongoose from "mongoose";

async function connectDb(){
    try {
        await mongoose.connect(process.env.MONGO_URI)
        const dbConnection = mongoose.connection
        dbConnection.on('db connected',()=>{
            console.log("connect to mongoDB")
        })
        dbConnection.on('error',(error)=>{
            console.log("connection failed "+error)
        })
    } catch (error) {
        console.log("Error in Database",error)
    }
}

export default connectDb

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 7: Database Connection`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,845 - INFO - RESPONSE (from cache): # Chapter 7: Database Connection

Welcome back! In [Chapter 6: Avatar Component](06_avatar_component.md), we learned how to display user profile pictures throughout our application. But all that user data, post data, and other information needs to be stored *somewhere*. That's where our **Database Connection** comes in!

Imagine your LinkedIn data  your profile, your posts, your connections  living inside a massive filing cabinet (the database). The Database Connection is like the special key that allows our application to open that filing cabinet and reliably read and write information to it. Without this key, our app can't access or modify the data!

**Why do we need a Database Connection?**

Think about what happens when you log into LinkedIn. The app needs to fetch your profile data from the database to display it. Or when you create a new post, the app needs to save that new post to the database. The Database Connection makes all of this possible.

Specifically, the Database Connection:

1.  **Establishes a connection:** It opens a line of communication between our application and the database.
2.  **Handles authentication:** It ensures that our application has the correct credentials (like a username and password) to access the database.
3.  **Manages the connection:** It keeps the connection alive and handles any errors that might occur.
4.  **Allows data transfer:** It enables us to send data to the database (like creating a new user) and retrieve data from the database (like fetching a user's profile).

**Key Concepts:**

Let's break down the key concepts of Database Connection:

*   **Connection String:** This is like the address and password for our database. It tells our application where to find the database and how to log in. It often contains information like the database server's address, the database name, a username, and a password. It's usually stored as an environment variable for security reasons.
*   **Database Client (Mongoose):**  This is a special tool that helps our application talk to the database. In our case, we are using Mongoose, which is a popular library for interacting with MongoDB databases. It provides a simpler and more structured way to perform database operations.
*   **Connection Pooling:** This is a technique that allows us to reuse existing database connections instead of creating a new connection every time we need to access the database. This can significantly improve the performance of our application.

**How do we use the Database Connection?**

In our application, we use the Database Connection to perform various database operations, such as:

*   **Creating a new user:** When a user registers for an account, we use the Database Connection to save their information to the database. You can see this in the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter.
*   **Fetching a user's profile:** When a user logs in, we use the Database Connection to retrieve their profile data from the database.
*   **Creating a new post:** When a user creates a new post, we use the Database Connection to save the post to the database.  Refer back to the [API Route Handlers](03_api_route_handlers.md) chapter and how it saves new Post data.

The main goal is to make sure that whenever we need to talk to our data storage, we can establish a connection successfully and safely.

**Internal Implementation:**

Let's take a peek under the hood! When our application starts up, it needs to establish a connection to the database.

Here's what happens step-by-step:

```mermaid
sequenceDiagram
    participant App
    participant Database Connection
    participant Mongoose
    participant MongoDB Database

    App->>Database Connection: Calls connectDB()
    Database Connection->>Mongoose: mongoose.connect(connectionString)
    Mongoose->>MongoDB Database: Establishes connection
    alt Connection Successful
        MongoDB Database-->>Mongoose: Connection confirmation
        Mongoose-->>Database Connection:  Connection confirmation
        Database Connection-->>App: Connection established
    else Connection Failed
        MongoDB Database-->>Mongoose: Error
        Mongoose-->>Database Connection: Error
        Database Connection-->>App: Error message
    end

```

1.  **App Calls connectDB():** Our application calls the `connectDB()` function to initiate the database connection.
2.  **Mongoose Connects:** The `connectDB()` function uses Mongoose to connect to the MongoDB database using the connection string.
3.  **Connection Attempt:** Mongoose attempts to establish a connection to the database using the provided connection string.
4.  **Success or Failure:**
    *   **Success:** If the connection is successful, Mongoose sends a confirmation message.
    *   **Failure:** If the connection fails (e.g., due to an invalid connection string or network issues), Mongoose sends an error message.
5.  **App Receives Confirmation or Error:** The `connectDB()` function receives either a confirmation message or an error message from Mongoose and handles it accordingly (e.g., logging a success message or displaying an error message).

Now, let's look at the actual code in `src\database\db.js`:

```javascript
import mongoose from "mongoose";

async function connectDb(){
    try {
        await mongoose.connect(process.env.MONGO_URI)
        const dbConnection = mongoose.connection
        dbConnection.on('db connected',()=>{
            console.log("connect to mongoDB")
        })
        dbConnection.on('error',(error)=>{
            console.log("connection failed "+error)
        })
    } catch (error) {
        console.log("Error in Database",error)
    }
}

export default connectDb
```

Let's break it down:

*   `import mongoose from "mongoose";`: This line imports the Mongoose library, which we'll use to interact with the MongoDB database.
*   `mongoose.connect(process.env.MONGO_URI)`: This is the key line that establishes the connection to the database. It uses the `mongoose.connect()` function, which takes the connection string as an argument.  `process.env.MONGO_URI` is an environment variable that stores the connection string.  Environment variables are a secure way to store sensitive information like database passwords.
*   `dbConnection.on('db connected',()=>{ console.log("connect to mongoDB") })`: This line sets up an event listener that will log a message to the console when the database connection is successfully established.
*   `dbConnection.on('error',(error)=>{ console.log("connection failed "+error) })`: This line sets up an event listener that will log an error message to the console if the database connection fails.
*   The code is wrapped in a `try...catch` block to handle any errors that might occur during the connection process.

Important Note: The `connectDb()` function *must* be called before performing any database operations.  You can see it being used in `/api/login` in the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter and `/api/post/like` in [API Route Handlers](03_api_route_handlers.md).

**Conclusion:**

In this chapter, we learned about the Database Connection. We saw how it acts as the key to our database, allowing our application to reliably read and write data. We explored the key concepts of connection strings, database clients, and connection pooling, and we looked at the internal implementation of the Database Connection in our application.

In the next chapter, we'll delve into [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md), which helps add and remove friends using this Database Connection.

2025-05-30 19:09:12,847 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "Handle Add Remove Friends Helper". This is Chapter 8.

Concept Details:
- Name: Handle Add Remove Friends Helper
- Description:
This helper function encapsulates the logic for adding and removing friends.  It makes a request to the API to perform the add/remove operation.  It's like a dedicated tool for managing friendships in the application. It avoids code duplication when adding/removing friends from different components.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

---
# Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.

---
# Chapter 4: Post Data Model

Welcome back! In [Chapter 3: API Route Handlers](03_api_route_handlers.md), we learned how to handle requests to create, update, and delete data. But what *is* that data we're working with when it comes to posts? That's where the **Post Data Model** comes in!

Imagine you're scrolling through your LinkedIn feed. Every post you see has some text, maybe an image, the user who posted it, and some likes and comments. The Post Data Model is like a template that defines what information each post contains and how it's organized.

Think of it like this: if the User Data Model (which you learned about in [Chapter 2: User Data Model](02_user_data_model.md)) is a blueprint for how to store user information, the Post Data Model is a blueprint for how to store post information!

**Why do we need a Post Data Model?**

Just like we needed a User Data Model to keep user data organized, we need a Post Data Model to keep post data organized. Without it, our application wouldn't know what to expect from each post, and it would be difficult to display and manage posts correctly.

Specifically, the Post Data Model ensures:

1.  **Consistency:** Every post has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a post.
3.  **Structure:** We know exactly where to find each piece of information for every post.

**Key Concepts:**

Let's break down what makes up our Post Data Model. It defines the properties (or attributes) of a post.

*   **Properties:** These are the individual pieces of information we store about each post. Examples include:

    *   `description`: The text content of the post (e.g., "Excited to share this article!").
    *   `image`: A link to an image in the post (if any).
    *   `userId`: The ID of the user who created the post. This links the post back to the user.
    *   `like`: An array containing the IDs of users who liked the post.
    *   `comment`: An array of comments related to the post.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., description, image URLs).
    *   `Array`: A list of things (e.g., a list of user IDs who liked the post, a list of comments).
    *   `ObjectId`: A special type of ID used to link data between different parts of our database (e.g., linking a post to a user).

**How do we use the Post Data Model?**

Let's say we want to create a new post in our application. We'd use the Post Data Model as a template. We'd provide the necessary information (description, image URL, user ID), and our application would create a new post object based on the model.

Here's a simplified example (conceptually):

```javascript
const newPost = {
  description: "Check out my new project!",
  image: "https://example.com/image.jpg",
  userId: "654321abcdef0123456789" // The ID of the user who created the post
};
```

This `newPost` object now has the structure defined by our Post Data Model.

**Internal Implementation:**

Let's take a peek under the hood! When a user creates a new post, here's what happens:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/create)
    participant Post Data Model
    participant Database

    User->>Client-side App: Creates a new post
    Client-side App->>API Route (/api/post/create): Sends post data (description, image, userId)
    API Route (/api/post/create)->>Post Data Model: Creates a new post object based on model
    Post Data Model->>Database: Saves the new post object
    Database-->>API Route (/api/post/create): Returns success or error
    API Route (/api/post/create)-->>Client-side App: Returns success or error
    Client-side App->>User: Displays the new post
```

1.  **User Input:** The user creates a new post in the Client-side App.
2.  **API Request:** The Client-side App sends the post data to the `/api/post/create` route.
3.  **Model Creation:** The `/api/post/create` route uses the Post Data Model as a blueprint to create a new post object.
4.  **Database Save:** The new post object is saved to the database.

Now, let's look at the actual code in `src\models\postModel.js`:

```javascript
import mongoose from 'mongoose'

const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : mongoose.Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    }
},{
    timestamps : true
})

const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel
```

Let's break it down:

*   `mongoose.Schema({...})`: This defines the structure of our post data.
*   `description : { type : String, default : "" }`: This says the `description` property must be a string, and if no description is provided, it defaults to an empty string.
*   `userId : { type : mongoose.Schema.Types.ObjectId, required : true, ref : 'users' }`: This says the `userId` property must be a special `ObjectId` that links to a user in the `users` collection.  `required : true` means a post can't be created without a user ID. `ref : 'users'` means this ID refers to a document in the `users` collection.
*   `timestamps: true`: This option lets the database automatically create `createdAt` and `updatedAt` fields.

```javascript
    like : {
         type : Array,
         default : []
    }
```

This snippet creates an Array which contains the list of users who "liked" the post.

The code from [API Route Handlers](03_api_route_handlers.md) which likes a post uses this model!

**Conclusion:**

In this chapter, we learned about the Post Data Model. We saw how it acts as a blueprint for post data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and how they're used to represent a post in our application.

Next, we'll explore the [Context Provider (ContextData)](05_context_provider__contextdata_.md), which helps us share data across different parts of our application.

---
# Chapter 5: Context Provider (ContextData)

Welcome back! In [Chapter 4: Post Data Model](04_post_data_model.md), we learned how to structure post data in our LinkedIn clone. But what if we want to show the currently logged-in user's name and profile picture in multiple places on the page, like the header and the post upload section? We *could* pass the user data as props to each component, but that can get messy and repetitive! That's where the **Context Provider (ContextData)** comes to the rescue!

Think of ContextData like a central bulletin board where you can pin important information that many different components need to access. In our case, that information is the currently logged-in user. Any component that needs the user's information can simply "read" it from the ContextData, without having to receive it directly as a prop from its parent.

**Why do we need a Context Provider?**

Imagine you're building a house. You could run individual electrical wires from the power source to each light fixture, but that's inefficient. Instead, you use a central electrical panel to distribute power to all the rooms. Context Provider is like that electrical panel  it provides a central place to manage and share data across your application.

Specifically, Context Provider helps us:

1.  **Avoid Prop Drilling:** We don't have to pass data through multiple layers of components that don't actually need it.
2.  **Centralize Data:** We have one place to manage the data, making it easier to update and maintain.
3.  **Improve Code Readability:** Components can directly access the data they need, making the code easier to understand.

**Key Concepts:**

Let's break down the key concepts of Context Provider:

*   **Context:** Think of this as the "bulletin board" itself. It holds the data we want to share.
*   **Provider:** This is the component that "pins" the data to the context. It makes the data available to all its child components.
*   **Consumer (or `useContext` hook):** This is how components "read" the data from the context. They subscribe to the context and get notified whenever the data changes.

**How do we use the Context Provider?**

Let's say we want to display the currently logged-in user's name in the header. We'd do the following:

1.  **Create a Context:** We create a `ContextData` object using `createContext`. This is our bulletin board.
2.  **Create a Provider:**  We wrap our entire application (or a large part of it) with the `ContextData.Provider`. This is like putting the bulletin board up in a central location.
3.  **Provide the User Data:** Inside the `Provider`, we set the `value` prop to the user data. This is like pinning the user's name and profile picture to the bulletin board.
4.  **Consume the Data:** In the header component, we use the `useContext` hook to access the user data from the `ContextData`. This is like a component walking up to the bulletin board and reading the user's name.

Here's a simplified example of how to use Context Provider (using snippets from `src\providers\provider.js` and `src\components\Header.js`):

First, in `src\providers\provider.js`, we create our Context and Provider:

```javascript
import { createContext, useState, useEffect } from "react";

export const ContextData = createContext(null);

export const Provider = ({ children }) => {
    const [user, setData] = useState(null); // store user in state

    //...fetch user details
    return (
        <ContextData.Provider value={{ user }}>
            {children}
        </ContextData.Provider>
    );
};
```

Explanation:

* We import `createContext` and `useState` from React.
* We create a context called `ContextData`. It's initially `null` before we provide data to it.
* We create a `Provider` component that wraps our app. This is what makes the data available.
* We use `useState` to store the `user` data. This will be the current user.
* MOST IMPORTANTLY: We pass the `user` state variable as the `value` prop to `ContextData.Provider`. This "pins" the user data to the context, making it accessible to all child components wrapped by provider. `children` prop represent children components which will share the state.

Now, in `src\components\Header.js`, we use the `useContext` hook to access the user data:

```javascript
import { useContext } from "react";
import { ContextData } from "@/providers/provider";

const Header = () => {
    const { user } = useContext(ContextData);

    return (
        <header>
            {user ? <p>Welcome, {user.firstName}!</p> : <p>Please log in</p>}
        </header>
    );
};
```

Explanation:

*   We import `useContext` and our `ContextData`.
*   We call `useContext(ContextData)` to get the value that was provided by the `ContextData.Provider`. In our case, it's the `user` object.
*   Now we can access the user's `firstName` directly! If a user has logged in and has name "Alice", it will display "Welcome, Alice!".

That's it!  The `Header` component now has access to the current user's information without having to receive it as a prop. You can do this in other components as well!

**Internal Implementation:**

Let's see what happens under the hood when a component uses the `useContext` hook:

```mermaid
sequenceDiagram
    participant Component
    participant ContextData
    participant Provider

    Component->>ContextData: useContext(ContextData)
    ContextData->>Provider: Requests current value
    Provider-->>ContextData: Returns user data
    ContextData-->>Component: Returns user data
    Component->>Component: Renders with user data
```

1.  **Component calls useContext:** The component calls `useContext(ContextData)` to access the data.
2.  **ContextData requests from Provider:** The `useContext` hook internally asks the `Provider` for the current value of the context.
3.  **Provider returns data:** The `Provider` returns the user data that it's currently holding in its state.
4.  **Component receives data:** The `useContext` hook returns the user data to the component.
5.  **Component renders:** The component re-renders with the new user data.

Looking at the actual code (again from `src\providers\provider.js`), here's what's happening behind the scenes:

```javascript
export const Provider = ({ children }) => {
    const [user, setData] = useState(null);

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return (
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    );
};
```

Explanation:

*   The `Provider` component fetches the current user's details.
*   The `fetchCurrentUserDetails` API call uses API Route Handler you learned in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   The `value` prop of `ContextData.Provider` is an object containing the `user` data, as well as the `fetchCurrentUserDetails` function which components can use to update the user details globally.

The files `src\app\(root)\page.js` ,`src\app\(root)\find-friends\page.js`, `src\app\(root)\[id]\page.js` and `src\components\PostDisplay.js` all use `useContext` hook to read user and `fetchCurrentUserDetails` states, so they can access user name, profile and update information.

**Conclusion:**

In this chapter, we learned about Context Provider (ContextData). We saw how it helps us share data across different components without prop drilling, centralizing data management, and improving code readability. We explored the key concepts of context, provider, and consumer, and saw how they work together.

In the next chapter, we'll learn about the [Avatar Component](06_avatar_component.md), which displays user profile pictures.

---
# Chapter 6: Avatar Component

Welcome back! In [Chapter 5: Context Provider (ContextData)](05_context_provider__contextdata_.md), we learned how to share user data across different components. Now, let's say we want to display user profile pictures in various places, like the header, post sections, and friend lists. We want a consistent look and feel everywhere, and we want to make it easy to navigate to the user's profile when you click the picture. This is where the **Avatar Component** comes in handy!

Think of the Avatar Component as a standardized frame for displaying user profile photos. It takes the user's profile picture URL and renders it within a consistent, circular frame. It also handles navigation to the user's profile page when you click on it. It's like having a reusable photo frame that you can put anywhere in your app!

**Why do we need an Avatar Component?**

Without an Avatar Component, we'd have to write the same code to display a profile picture every time we needed it. We'd have to handle image loading, styling (making it circular, setting the size), and navigation separately each time. This would lead to:

1.  **Repetitive Code:** We'd be writing the same code over and over again.
2.  **Inconsistent Look and Feel:** Different profile pictures might have slightly different styles.
3.  **Maintenance Nightmare:** If we wanted to change the style of all profile pictures, we'd have to update the code in multiple places.

The Avatar component helps us solve the issues.

**Key Concepts:**

Let's break down the key concepts of the Avatar Component:

*   **Reusability:** The Avatar Component is a reusable piece of UI that can be used in multiple places throughout the application.
*   **Consistency:** It ensures that all profile pictures have a consistent look and feel.
*   **Navigation:** It handles navigation to the user's profile page when clicked.

**How do we use the Avatar Component?**

Let's say we want to display a user's profile picture in the header of our application. We'd use the Avatar Component like this (referencing `src\components\Header.js`):

```javascript
<Avatar
    userId={user?._id}
    imageURL={user?.profile_pic}
    width={28}
    height={28}
    disable={true}
/>
```

Explanation:

*   `userId`: The ID of the user whose profile picture we want to display.
*   `imageURL`: The URL of the user's profile picture.
*   `width`: The width of the avatar in pixels.
*   `height`: The height of the avatar in pixels.
*   `disable`: If `true`, the avatar won't be clickable (no navigation).

When this code runs, the Avatar Component will:

1.  Load the image from the `imageURL`.
2.  Display the image in a circular frame with the specified `width` and `height`.
3.  Make the avatar clickable, navigating to the user's profile page when clicked (unless `disable` is set to `true`).

If `imageURL` is missing, it will display a default user icon.

**Internal Implementation:**

Let's see what happens under the hood when the Avatar Component is rendered:

```mermaid
sequenceDiagram
    participant Component
    participant Avatar Component
    participant Image (or Default Icon)
    participant Link

    Component->>Avatar Component: Renders Avatar Component with imageURL and userId
    Avatar Component->>Image (or Default Icon): Checks if imageURL exists
    alt imageURL exists
        Avatar Component->>Image: Renders Image component with imageURL
    else imageURL doesn't exist
        Avatar Component->>Image: Renders Default Icon
    end
    Avatar Component->>Link: Renders Link component with href to user profile
    Link->>Component: Returns rendered Avatar with clickable link
```

1.  **Component Renders Avatar:** A component renders the Avatar Component, passing in the `imageURL` and `userId`.
2.  **Avatar Checks for Image:** The Avatar Component checks if the `imageURL` exists.
3.  **Render Image or Icon:**
    *   If the `imageURL` exists, it renders an `Image` component with the provided URL.
    *   If the `imageURL` is missing, it renders a default user icon.
4.  **Wrap in Link:**  The Avatar Component wraps the image (or icon) in a `Link` component, which makes it clickable and navigates to the user's profile page (e.g., `/user/123`).
5.  **Returns Rendered Avatar:** The Avatar Component returns the rendered avatar with the clickable link.

Now, let's look at the actual code in `src\components\Avatar.js`:

```javascript
import React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar
```

Let's break it down:

*   `imageURL`, `userId`, `width`, and `height` are props passed to the component.
*   The component uses conditional rendering (`imageURL ? ... : ...`) to display either the image or a default icon, which keeps the UI consistent.
*   If `imageURL` is exist, it uses Next.js's `Image` component to display the profile picture. `className='rounded-full'` makes the image circular.
*   `Link` is the next.js component to enable routing by wrapping the Image component.
*   `<Link href={"/"+userId}>` creates a link to the user's profile page. When `disable` is false, the link goes to that user's profile page; otherwise, it does nothing.
*   `usePathname` is a Next.js hook to get the current URL.

The [Context Provider (ContextData)](05_context_provider__contextdata_.md) chapter gives several examples of the Avatar component used to display user profile images.

**Conclusion:**

In this chapter, we learned about the Avatar Component. We saw how it helps us display user profile pictures consistently and easily throughout our application. We explored the key concepts of reusability, consistency, and navigation, and we looked at the internal implementation of the Avatar Component.

In the next chapter, we'll delve into the [Database Connection](07_database_connection.md), which handles connection and querying to DB.

---
# Chapter 7: Database Connection

Welcome back! In [Chapter 6: Avatar Component](06_avatar_component.md), we learned how to display user profile pictures throughout our application. But all that user data, post data, and other information needs to be stored *somewhere*. That's where our **Database Connection** comes in!

Imagine your LinkedIn data  your profile, your posts, your connections  living inside a massive filing cabinet (the database). The Database Connection is like the special key that allows our application to open that filing cabinet and reliably read and write information to it. Without this key, our app can't access or modify the data!

**Why do we need a Database Connection?**

Think about what happens when you log into LinkedIn. The app needs to fetch your profile data from the database to display it. Or when you create a new post, the app needs to save that new post to the database. The Database Connection makes all of this possible.

Specifically, the Database Connection:

1.  **Establishes a connection:** It opens a line of communication between our application and the database.
2.  **Handles authentication:** It ensures that our application has the correct credentials (like a username and password) to access the database.
3.  **Manages the connection:** It keeps the connection alive and handles any errors that might occur.
4.  **Allows data transfer:** It enables us to send data to the database (like creating a new user) and retrieve data from the database (like fetching a user's profile).

**Key Concepts:**

Let's break down the key concepts of Database Connection:

*   **Connection String:** This is like the address and password for our database. It tells our application where to find the database and how to log in. It often contains information like the database server's address, the database name, a username, and a password. It's usually stored as an environment variable for security reasons.
*   **Database Client (Mongoose):**  This is a special tool that helps our application talk to the database. In our case, we are using Mongoose, which is a popular library for interacting with MongoDB databases. It provides a simpler and more structured way to perform database operations.
*   **Connection Pooling:** This is a technique that allows us to reuse existing database connections instead of creating a new connection every time we need to access the database. This can significantly improve the performance of our application.

**How do we use the Database Connection?**

In our application, we use the Database Connection to perform various database operations, such as:

*   **Creating a new user:** When a user registers for an account, we use the Database Connection to save their information to the database. You can see this in the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter.
*   **Fetching a user's profile:** When a user logs in, we use the Database Connection to retrieve their profile data from the database.
*   **Creating a new post:** When a user creates a new post, we use the Database Connection to save the post to the database.  Refer back to the [API Route Handlers](03_api_route_handlers.md) chapter and how it saves new Post data.

The main goal is to make sure that whenever we need to talk to our data storage, we can establish a connection successfully and safely.

**Internal Implementation:**

Let's take a peek under the hood! When our application starts up, it needs to establish a connection to the database.

Here's what happens step-by-step:

```mermaid
sequenceDiagram
    participant App
    participant Database Connection
    participant Mongoose
    participant MongoDB Database

    App->>Database Connection: Calls connectDB()
    Database Connection->>Mongoose: mongoose.connect(connectionString)
    Mongoose->>MongoDB Database: Establishes connection
    alt Connection Successful
        MongoDB Database-->>Mongoose: Connection confirmation
        Mongoose-->>Database Connection:  Connection confirmation
        Database Connection-->>App: Connection established
    else Connection Failed
        MongoDB Database-->>Mongoose: Error
        Mongoose-->>Database Connection: Error
        Database Connection-->>App: Error message
    end

```

1.  **App Calls connectDB():** Our application calls the `connectDB()` function to initiate the database connection.
2.  **Mongoose Connects:** The `connectDB()` function uses Mongoose to connect to the MongoDB database using the connection string.
3.  **Connection Attempt:** Mongoose attempts to establish a connection to the database using the provided connection string.
4.  **Success or Failure:**
    *   **Success:** If the connection is successful, Mongoose sends a confirmation message.
    *   **Failure:** If the connection fails (e.g., due to an invalid connection string or network issues), Mongoose sends an error message.
5.  **App Receives Confirmation or Error:** The `connectDB()` function receives either a confirmation message or an error message from Mongoose and handles it accordingly (e.g., logging a success message or displaying an error message).

Now, let's look at the actual code in `src\database\db.js`:

```javascript
import mongoose from "mongoose";

async function connectDb(){
    try {
        await mongoose.connect(process.env.MONGO_URI)
        const dbConnection = mongoose.connection
        dbConnection.on('db connected',()=>{
            console.log("connect to mongoDB")
        })
        dbConnection.on('error',(error)=>{
            console.log("connection failed "+error)
        })
    } catch (error) {
        console.log("Error in Database",error)
    }
}

export default connectDb
```

Let's break it down:

*   `import mongoose from "mongoose";`: This line imports the Mongoose library, which we'll use to interact with the MongoDB database.
*   `mongoose.connect(process.env.MONGO_URI)`: This is the key line that establishes the connection to the database. It uses the `mongoose.connect()` function, which takes the connection string as an argument.  `process.env.MONGO_URI` is an environment variable that stores the connection string.  Environment variables are a secure way to store sensitive information like database passwords.
*   `dbConnection.on('db connected',()=>{ console.log("connect to mongoDB") })`: This line sets up an event listener that will log a message to the console when the database connection is successfully established.
*   `dbConnection.on('error',(error)=>{ console.log("connection failed "+error) })`: This line sets up an event listener that will log an error message to the console if the database connection fails.
*   The code is wrapped in a `try...catch` block to handle any errors that might occur during the connection process.

Important Note: The `connectDb()` function *must* be called before performing any database operations.  You can see it being used in `/api/login` in the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter and `/api/post/like` in [API Route Handlers](03_api_route_handlers.md).

**Conclusion:**

In this chapter, we learned about the Database Connection. We saw how it acts as the key to our database, allowing our application to reliably read and write data. We explored the key concepts of connection strings, database clients, and connection pooling, and we looked at the internal implementation of the Database Connection in our application.

In the next chapter, we'll delve into [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md), which helps add and remove friends using this Database Connection.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\app\(root)\page.js ---
'use client'
import ProfileCard from "@/components/ProfileCard";
import UploadPost from "@/components/UploadPost";
import { ContextData } from "@/providers/provider";
import { useContext, useEffect, useState } from "react";
import axios from 'axios'
import PostDisplay from "@/components/PostDisplay";
import Avatar from "@/components/Avatar";
import Divider from "@/components/Divider";
import handleAddRemoveFriends from "@/helpers/handleAddRemoveFriends";
import toast from 'react-hot-toast'
import News from "@/components/News";

export default function Home() {
  const {user, fetchCurrentUserDetails} = useContext(ContextData)
  const [postData,setPostData] = useState([])
  const [friendsList,setFriendsList] = useState([])

  const fetchPost = async()=>{
    const response = await axios.get("/api/post")
    setPostData(response.data.data || [])
  }

  const fetchFriendsList = async()=>{
    const response = await axios.get('/api/friends')
    setFriendsList(response.data.data)
  }

  useEffect(()=>{
    fetchPost()
    fetchFriendsList()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchFriendsList()
    toast(response.message)
  }

  return (
   <div className="container mx-auto p-4 lg:grid grid-cols-[280px,1fr,280px] gap-7 h-full items-start">
        {/*** current user profile*/}
        <section className="bg-white rounded p-2 lg:sticky lg:top-20">
          <ProfileCard
            _id={user?._id}
            profile_pic={user?.profile_pic}
            firstName={user?.firstName || ''}
            lastName={user?.lastName || ''}
            location={user?.location || ''}
            occupation={user?.occupation || ''}
            friends = {user?.friends || []}
          />
          <hr className="m-3"/>
          <h1 className="font-bold mb-3">Your Connections:</h1>
            <div>
              {
                friendsList.map((friend,index)=>{
                  return(
                    <div key={friend?._id}>
                      <div className="flex items-center gap-3 justify-between">
                        <div className="flex items-center gap-3">
                          <Avatar
                            userId={friend._id}
                            width={40}
                            height={40}
                            imageURL={friend?.profile_pic}
                          />
                          <div>
                            <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                            <p className="text-xs">{friend.occupation}</p>
                          </div>
                        </div>
                        <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                      </div>
                      <Divider/>
                    </div>
                  )
                })
              }
            </div>
        </section>


        {/*** upload post and see post*/}
        <section className="rounded mt-5 lg:mt-0">
            <UploadPost
               _id={user?._id}
               profile_pic={user?.profile_pic}
               callApi={fetchPost}
            />

            <div>
                {
                  postData.map((post,index)=>{
                    return(
                      <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                    )
                  })
                }
            </div>

        </section>


         {/*** ads and friend list*/}
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
            <div className="flex flex-row">
            <News/>
            </div>
        </section>
   </div>
  );
}

--- File: src\app\(root)\find-friends\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import { ContextData } from '@/providers/provider'
import toast from 'react-hot-toast'

const FindFriends = () => {
  const [allUser,setAllUser] = useState([])
  const {user, fetchCurrentUserDetails} = useContext(ContextData)

  const fetchAllUser = async()=>{
    const response = await axios.get("/api/all-users")
    const friendList = user?.friends || []
    const removeFriends = response.data.data.filter(userDetails => !friendList.includes(userDetails?._id))
    const removeCurrentUser = removeFriends.filter(userDetails => userDetails?._id !== user?._id) 
    setAllUser(removeCurrentUser)
  }

  useEffect(()=>{
    fetchAllUser()
  },[])

  const handleAddFriend = async(friendId)=>{
    const response = await handleAddRemoveFriends(friendId)
    fetchCurrentUserDetails()
    fetchAllUser()
    toast(response.message)
  }
  return (
    <div className='container mx-auto p-4'>

        <h3 className='font-semibold text-lg mb-3'>Find <span className='text-orange-500 font-extrabold'>New</span> Friends</h3>
        <div className='flex flex-wrap gap-4'>
          {
              allUser.map((user,index)=>{
                return(
                  <div key={index} className='bg-white p-4 flex justify-center flex-col items-center gap-1 min-w-[180px] min-h-[180px]'>
                      <Avatar
                        userId={user?._id}
                        imageURL={user?.profile_pic}
                        width={60}
                        height={60}
                      />
                      <p className='text-lg font-medium capitalize my-0'>{user.firstName} {user.lastName}</p>
                      <p className='text-xs my-0 -mt-2'>{user.occupation}</p>
                      <button className='bg-blue-800 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm mt-2' onClick={()=>handleAddFriend(user?._id)}>Add Friend</button>
                  </div>
                )
              })
          }
        </div>

    </div>
  )
}

export default FindFriends

--- File: src\app\(root)\[id]\page.js ---
'use client'
import React, { useContext, useEffect, useState } from 'react'
import axios from 'axios'
import Avatar from '@/components/Avatar'
import { ContextData } from '@/providers/provider'
import PostDisplay from '@/components/PostDisplay'
import handleAddRemoveFriends from '@/helpers/handleAddRemoveFriends'
import Divider from '@/components/Divider'

const UserProfileDetails = ({ params }) => {
    const [data,setData] = useState(null)
    const [friendslist,setFirendsList] = useState([])
    const [postData,setPostData] = useState([])
    const {user, fetchCurrentUserDetails} = useContext(ContextData)
    const [loading,setLoading] = useState(false)
    
    const fetchUserDetails  = async()=>{
      const payload  = {
        userId : params.id
      }
      setLoading(true)
      const response  = await axios.post("/api/user-details",payload)

      setData(response.data.data)
      setFirendsList(response.data.friends)
      setPostData(response.data.post)
      setLoading(false)
    }

    const handleAddFriend = async(friendId)=>{
      const response = await handleAddRemoveFriends(friendId)
      fetchUserDetails()
    }

    useEffect(()=>{
      fetchUserDetails()
    },[])

    const isDisplayAddFriend = user?.friends?.includes(data?._id) || user?._id === data?._id
  return (
    <div className='container mx-auto'>

        <div className='mt-5 grid gap-10 lg:grid-cols-[2fr,1fr] items-start'>
            {/**user information and post */}
            <div className=''>
                {/**user information */}
                <div className='bg-white p-4'>
                      <div className='h-36 bg-slate-200 rounded mb-14'>
                          <div className='bg-white h-36 w-36 rounded-full translate-x-8 translate-y-1/3 p-1 flex justify-center items-center'>
                              <Avatar
                                imageURL={data?.profile_pic}
                                userId={data?._id}
                                width={130}
                                height={130}
                              />
                          </div>
                      </div>
                      <p className='font-bold text-lg lg:text-2xl capitalize'>{data?.firstName} {data?.lastName}</p>
                      <p className='text-base lg:text-lg'>{data?.occupation}</p>

                      {
                        !isDisplayAddFriend && (
                          <button className='bg-blue-800 hover:bg-blue-700 text-white font-semibold px-5 rounded-full my-3 py-2'>Add Friend</button>
                        )
                      }
                </div>

                {/***post */}
                    <div className='w-full'>
                    {
                      postData.map((post,index)=>{
                        return(
                          <PostDisplay data={post} key={post._id} handleAddFriend={handleAddFriend}/>
                        )
                      })
                    }
                  </div> 
            </div>
         <section className="bg-white rounded p-4 lg:sticky lg:top-20">
              
              <h1 className="font-bold mb-3">Friends List:</h1>
              <div>
                {
                  friendslist.map((friend,index)=>{
                    return(
                      <div key={friend?._id}>
                        <div className="flex items-center gap-3 justify-between">
                          <div className="flex items-center gap-3">
                              <Avatar
                                userId={friend._id}
                                width={40}
                                height={40}
                                imageURL={friend?.profile_pic}
                              />
                              <div>
                                <p className="font-semibold">{friend?.firstName} {friend?.lastName}</p>  
                                <p className="text-xs">{friend.occupation}</p>
                              </div>
                          </div>
                          <button className="border-blue-800 border text-blue-800 rounded-full text-xs px-1 hover:bg-blue-800 hover:text-white py-1" onClick={()=>handleAddFriend(friend._id)}>Unfriend</button>
                        </div>

                        <Divider/>
                      </div>
                    )
                  })
                }
              </div>
  
          </section>


        </div>


        {
          loading && (
            <div className='fixed top-0 bottom-0 right-0 left-0 bg-slate-500 bg-opacity-25 flex justify-center items-center'>
              <p className='bg-white px-6 py-2 text-lg'>Loading...</p>
            </div>
          )
        }
    </div>
  )
}

export default UserProfileDetails

--- File: src\helpers\handleAddRemoveFriends.js ---
import axios from 'axios'

const handleAddRemoveFriends = async(friendId) =>{
    const payload = {
        friendId : friendId
    }
    const response = await axios.post('/api/add-remove-friends',payload)

    return response.data
}

export default handleAddRemoveFriends

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 8: Handle Add Remove Friends Helper`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,889 - INFO - RESPONSE (from cache): # Chapter 8: Handle Add Remove Friends Helper

Welcome back! In [Chapter 7: Database Connection](07_database_connection.md), we learned how our application connects to the database. Now, let's imagine a common scenario: you're browsing LinkedIn and want to connect with a new contact. You click "Add Friend," and *poof*, you're connected! How does our application handle adding and removing friends without repeating the same code everywhere? That's where the **Handle Add Remove Friends Helper** comes to the rescue!

Think of this helper function as a dedicated tool in your toolbox, specifically designed for managing friendships.  Instead of writing out the instructions for adding or removing a friend *every single time* you need to, you just grab this tool and use it.

**Why do we need a Helper Function for Adding/Removing Friends?**

Imagine you have "Add Friend" buttons on different parts of your LinkedIn clone: on user profiles, in search results, and maybe even in a "suggested friends" list. Without a helper, you'd need to copy and paste the same code for each of those buttons. This would be:

1.  **Repetitive:**  Writing the same code over and over is tedious!
2.  **Error-prone:**  Copying and pasting can lead to mistakes.
3.  **Hard to Maintain:**  If you need to change *how* adding a friend works (e.g., add a confirmation message), you'd have to update it in *every* single place!

The "Handle Add Remove Friends Helper" solves all of these problems by centralizing the logic.

**Key Concepts:**

Let's break down what this helper does:

*   **Encapsulation:** The helper *encapsulates* (wraps up) all the logic for adding or removing a friend into a single, reusable function.
*   **API Request:**  It makes a request to our API (the backend part of our application) to actually perform the add/remove operation in the database. You can see how the API works in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   **Reusability:**  You can call this helper from *any* component in your application.

**How do we use the Handle Add Remove Friends Helper?**

Let's say you're on a user's profile page and you want to add them as a friend. Here's how you'd use the helper (referencing `src\app\(root)\[id]\page.js`):

```javascript
const handleAddFriend = async(friendId)=>{
  const response = await handleAddRemoveFriends(friendId);
  fetchUserDetails();
}
```

Explanation:

1.  `handleAddFriend` function is called (for example, when you click an "Add Friend" button).
2.  `friendId` is the ID of the user you want to add/remove.
3.  `await handleAddRemoveFriends(friendId)` calls the helper function, passing in the `friendId`. This triggers the API request to add/remove friend.
4.  `fetchUserDetails()`: After the friend is added/removed, it calls a function to update the user details on the page.

The helper function then returns a response containing the status of the operation, after doing some magic in the background.

**Internal Implementation:**

Let's see what happens under the hood when you call the Handle Add Remove Friends Helper.

```mermaid
sequenceDiagram
    participant User Interface
    participant Handle Add Remove Friends Helper
    participant API Route (/api/add-remove-friends)
    participant Database

    User Interface->>Handle Add Remove Friends Helper: handleAddRemoveFriends(friendId)
    Handle Add Remove Friends Helper->>API Route (/api/add-remove-friends): Sends POST request with friendId
    API Route (/api/add-remove-friends)->>Database: Updates user's friend list (add/remove)
    Database-->>API Route (/api/add-remove-friends): Returns success/error
    API Route (/api/add-remove-friends)-->>Handle Add Remove Friends Helper: Returns success/error message
    Handle Add Remove Friends Helper->>User Interface: Returns success/error message
```

1.  **User Clicks Button:** The user clicks an "Add Friend" or "Remove Friend" button in the User Interface.
2.  **Helper is Called:** The `handleAddRemoveFriends` helper function is called, passing in the `friendId`.
3.  **API Request:**  The helper sends a `POST` request to the `/api/add-remove-friends` API route, including the `friendId` in the request body.
4.  **Database Update:** The API route handles the logic to either add the `friendId` to the current user's friend list or remove it if it's already there.  This involves updating the database, which you learned about in [Chapter 7: Database Connection](07_database_connection.md) and [Chapter 2: User Data Model](02_user_data_model.md).
5.  **Response:** The API route sends a response back to the helper, indicating success or failure.
6.  **Message to User:** The helper might display a message to the user (e.g., "Friend added!" or "Friend removed!").

Now, let's look at the actual code in `src\helpers\handleAddRemoveFriends.js`:

```javascript
import axios from 'axios'

const handleAddRemoveFriends = async(friendId) =>{
    const payload = {
        friendId : friendId
    }
    const response = await axios.post('/api/add-remove-friends',payload)

    return response.data
}

export default handleAddRemoveFriends
```

Let's break it down:

*   `import axios from 'axios'`: This line imports the `axios` library, which we use to make HTTP requests to our API.
*   `const payload = { friendId : friendId }`: This creates an object called `payload` containing the `friendId`. This is the data we're sending to the API.
*   `const response = await axios.post('/api/add-remove-friends',payload)`: This line makes a `POST` request to the `/api/add-remove-friends` API route, sending the `payload` (the friend ID) along with the request.
*   `return response.data`:  This line returns the data that the API sends back, which will contain a success/error message.

Important Note:  The helper function *doesn't* directly modify the database. It sends a request to an API route, which *then* interacts with the database. This separation of concerns makes our code more organized and easier to maintain.

**Conclusion:**

In this chapter, we learned about the Handle Add Remove Friends Helper. We saw how it encapsulates the logic for adding and removing friends, making our code more reusable, less error-prone, and easier to maintain. We explored the key concepts of encapsulation, API requests, and reusability, and we looked at the internal implementation of the helper function.

In the next chapter, we'll explore [Image Upload Helper](09_image_upload_helper.md), which helps us upload and manage images in our application.

2025-05-30 19:09:12,891 - INFO - PROMPT: 
Write a very beginner-friendly tutorial chapter (in Markdown format) for the project `LinkedIn` about the concept: "Image Upload Helper". This is Chapter 9.

Concept Details:
- Name: Image Upload Helper
- Description:
This helper function handles uploading images to Cloudinary. It simplifies the process of uploading images and provides a consistent way to manage image storage.


Complete Tutorial Structure:
1. [User Authentication and Authorization](01_user_authentication_and_authorization.md)
2. [User Data Model](02_user_data_model.md)
3. [API Route Handlers](03_api_route_handlers.md)
4. [Post Data Model](04_post_data_model.md)
5. [Context Provider (ContextData)](05_context_provider__contextdata_.md)
6. [Avatar Component](06_avatar_component.md)
7. [Database Connection](07_database_connection.md)
8. [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md)
9. [Image Upload Helper](09_image_upload_helper.md)

Context from previous chapters:
# Chapter 1: User Authentication and Authorization

Welcome! This is the first step in building our LinkedIn project. In this chapter, we'll be focusing on **User Authentication and Authorization**. Think of it as the gatekeeper to our app  making sure only the right people get in and can do the right things.

**Why do we need it?**

Imagine someone trying to access your LinkedIn profile and make posts as you!  That's why we need authentication and authorization.

Let's say you want to build a simple LinkedIn clone where only logged-in users can post updates. This is a very common use case. Our "gatekeeper" will:

1.  **Authentication:** Verify *who* the user is (e.g., making sure they are who they say they are using their email and password). This is like checking their ID at the door.
2.  **Authorization:** Determine *what* the user is allowed to do (e.g., can they post updates, edit their profile, or just view content?). This is like checking if they have the right permissions to enter a VIP area.

**Key Concepts:**

Let's break down these concepts further:

*   **Authentication:** This is the process of verifying a user's identity.  Think of it as logging into your email account. You provide your email and password, and the system checks if they match.  If they do, you're authenticated! In our project, we'll use email and password to verify users.

*   **Authorization:** Once a user is authenticated (we know *who* they are), authorization determines what they are allowed to do.  For example, an administrator might be allowed to delete posts, while a regular user can only create and edit their own posts.  For our LinkedIn clone, we'll need to make sure only logged-in users can create posts and only authorized users can delete posts. (We will deal with roles later.)

*   **Middleware:** This is a piece of code that runs *before* a request reaches our application's main logic. It acts as a filter.  Our middleware will check if the user is logged in *before* allowing them to access certain pages.  If they're not logged in, we'll redirect them to the login page.

**How do we use it?**

Let's look at how these concepts are put to action:

1.  **Registration:** First, a new user needs to register with their email, password, and other necessary information (name, occupation, etc.). The code for registration is handled in `src\app\(auth)\register\page.js` and `src\app\api\register\route.js`. The registration form looks like this:

    ```html
    <form className='grid gap-4' onSubmit={handleSubmit}>
    ... inputs for registration ...
    <button
      type="submit"
      className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'
      disabled={loading}
    >
      {loading ? 'Registering...' : 'Register'}
    </button>
    </form>
    ```

    This form submits the data to our API route for registration.

2.  **Login:** An existing user logs in using their email and password. The code for the login page is in `src\app\(auth)\login\page.js`:

    ```javascript
    <form className='mt-4 grid gap-4' onSubmit={handleSubmit}>
        <div className='flex flex-col gap-1'>
            <label htmlFor='email'>Email:</label>
            <input type='email' name="email" id='email' value={data.email} placeholder='enter email'/>
        </div>
        <div className='flex flex-col gap-1'>
            <label htmlFor='password'>Password:</label>
            <input type='password' name="password" id='password' value={data.password} placeholder='enter password'/>
        </div>
        <button className='bg-blue-700 hover:bg-blue-800 py-2 px-4 font-semibold text-white rounded'>Login</button>
    </form>
    ```

    When the user clicks "Login", the `handleSubmit` function in the same file sends the email and password to the `/api/login` route.

3.  **Middleware Check:** When a user tries to access the main page (`/`), our `middleware.js` file steps in:

    ```javascript
    import { NextResponse } from 'next/server'

    export function middleware(request) {
        const path = request.nextUrl.pathname
        const isPublicPath = path === '/login' || path === '/register'
        const token = request.cookies.get('token')?.value || ''

        if(isPublicPath && token){
            return NextResponse.redirect(new URL('/',request.nextUrl))
        }

        if(!isPublicPath && !token){
            return NextResponse.redirect(new URL('/login',request.nextUrl))
        }
    }
    export const config = {
        matcher: [
            '/login',
            '/register',
            '/'
        ],
    }
    ```

    This code checks:

    *   If the user is trying to access `/login` or `/register` *while already logged in* (they have a token). If so, it redirects them to the main page (`/`).
    *   If the user is trying to access *any other* page (`/`) without being logged in (no token). If so, it redirects them to the login page (`/login`).

**Internal Implementation:**

Let's see what happens under the hood during the login process:

```mermaid
sequenceDiagram
    participant User
    participant Login Page
    participant API Route (/api/login)
    participant Database
    participant Auth Token

    User->>Login Page: Enters email and password
    Login Page->>API Route (/api/login): Sends email and password
    API Route (/api/login)->>Database: Queries user data
    Database-->>API Route (/api/login): Returns user data (or error)
    API Route (/api/login)->>Auth Token: Creates a token (JWT)
    API Route (/api/login)-->>Login Page: Sets token in cookie and returns success
    Login Page->>User: Redirects to main page

```

1.  **User Input:** The user enters their email and password on the Login Page (`src\app\(auth)\login\page.js`).

2.  **API Request:** The Login Page sends these credentials to the `/api/login` route (`src\app\api\login\route.js`).

3.  **Database Lookup:** The `/api/login` route:

    ```javascript
    import userModel from '@/models/userModel'
    import  { NextResponse } from 'next/server'
    import bcryptjs from 'bcryptjs'
    import jwt from 'jsonwebtoken'
    import connectDB from '@/database/db'

    connectDB()

    export async function POST(request){
        try {
            const { email , password } = await request.json()

            const user = await userModel.findOne({ email }) // Look up the user

            // ... (rest of the login logic)
        } catch (error) {
           return NextResponse.json({ message : error.message || error })
        }
    }
    ```

    This code first connects to the database using `connectDB()`, then tries to find a user with the provided email using `userModel.findOne({ email })`. [User Data Model](02_user_data_model.md) will show you the data schema for user.

4.  **Password Verification:** If the user is found, the route verifies the password using `bcryptjs.compare()` to compare entered password with hashed password in the DB.

5.  **Token Creation:** If the email and password are correct, a JSON Web Token (JWT) is created:

    ```javascript
    const tokenData = {
        id : user._id,
        email : user.email
    }

    const token = await jwt.sign(tokenData,process.env.SECRET_KEY_TOKEN,{ expiresIn : 60 * 60 * 8})
    ```

    The JWT contains the user's ID and email, and it's signed with a secret key (`process.env.SECRET_KEY_TOKEN`). This token is used to verify the user's identity in subsequent requests. The expiration time is set to 8 hours.

6.  **Cookie Setting:** The JWT is then stored in a cookie:

    ```javascript
    const response =  NextResponse.json({
        token : token,
        message : "Login successfully",
        success : true
    })

    const cookiesOption = {
        httpOnly : true,
        secure : true,
    }

    response.cookies.set("token",token,cookiesOption)
    return response
    ```

    Setting the token as a cookie ensures that the token is automatically included in subsequent requests to the server. `httpOnly: true` means the cookie can't be accessed by client-side JavaScript, and `secure: true` means the cookie is only sent over HTTPS.

7.  **Redirection:** Finally, the user is redirected to the main page (`/`).

**Conclusion:**

In this chapter, you learned about User Authentication and Authorization, which is like a gatekeeper that verifies identities and determines what users can do. We covered the key concepts of authentication, authorization, and middleware, and saw how they're used in our LinkedIn clone project. We also looked at the internal implementation of the login process, including database lookup, password verification, and token creation.

In the next chapter, we'll delve into the [User Data Model](02_user_data_model.md), which defines the structure of user data in our application.

---
# Chapter 2: User Data Model

Welcome back! In [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), we learned how to let users log in and register. But where do we *store* all that user information? That's where the **User Data Model** comes in!

Imagine you're building a simple social network. You need to store information about each user: their name, email, password, profile picture, and more. The User Data Model is like a blueprint that tells our application *exactly* what information to store and how to store it for each user.

**Why do we need a User Data Model?**

Without a User Data Model, we'd have chaos! We wouldn't know what information to expect from each user, and our application wouldn't be able to reliably work with user data. Think of it like this: without a blueprint, a construction crew wouldn't know how to build a house!

Specifically, the User Data Model ensures:

1.  **Consistency:** Every user has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a user in our application.
3.  **Structure:** We know exactly where to find each piece of information for every user.

**Key Concepts:**

Let's break down what makes up our User Data Model. In its simplest form, it defines the properties (or attributes) of a user.

*   **Properties:** These are the individual pieces of information we store about each user. Examples include:

    *   `firstName`: The user's first name (e.g., "Alice").
    *   `lastName`: The user's last name (e.g., "Smith").
    *   `email`: The user's email address (e.g., "alice.smith@example.com").
    *   `password`: The user's password (stored securely, of course!).
    *   `profile_pic`: A link to their profile picture.
    *   `friends`: List of user IDs of their friends.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., names, emails).
    *   `Number`: Numbers (e.g., age, number of friends).
    *   `Array`: A list of things (e.g., a list of friends).

**How do we use the User Data Model?**

Let's say we want to create a new user in our application. We'd use the User Data Model as a template. We'd provide the necessary information (first name, last name, email, password), and our application would create a new user object based on the model.

Here's a simplified example (conceptually, not the *exact* code we use, but close):

```javascript
const newUser = {
  firstName: "Bob",
  lastName: "Johnson",
  email: "bob.johnson@example.com",
  password: "securePassword123" // This would actually be a hashed password
};
```

This `newUser` object now has the structure defined by our User Data Model. Our application can easily access and use this information.

If the `email` was defined to be unique and we tried to create another user with "bob.johnson@example.com", the database would throw an error! This is because our User Data Model defined email as a unique property.

**Internal Implementation:**

Let's take a peek under the hood! When a new user registers, here's what happens:

```mermaid
sequenceDiagram
    participant User Registration Page
    participant API Route (/api/register)
    participant User Data Model
    participant Database

    User Registration Page->>API Route (/api/register): Sends user data (name, email, password)
    API Route (/api/register)->>User Data Model: Creates a new user object based on model
    User Data Model->>Database: Saves the new user object
    Database-->>API Route (/api/register): Returns success or error
    API Route (/api/register)-->>User Registration Page: Returns success or error
```

1.  **User Input:** The user fills out the registration form on the User Registration Page.
2.  **API Request:** The User Registration Page sends the data to the `/api/register` route.
3.  **Model Creation:** The `/api/register` route uses the User Data Model as a blueprint to create a new user object.
4.  **Database Save:** The new user object is saved to the database. The model ensure the data confirms with what the database expects!

Now, let's look at the actual code in `src\models\userModel.js`:

```javascript
import mongoose from "mongoose";

const userSchema = mongoose.Schema({
   firstName : {
        type : String,
        required : [true, "Provide first name"]
   },
   lastName : {
        type : String,
        required : [true, "Provide last name"]
   },
   email : {
        type : String,
        unique : true,
        required : [true, "Provide email id"]
   },
   password : {
        type : String,
        required : [true, "provide password"]
   }
},{
    timeStamps : true
})

const userModel = mongoose.models.users ||  mongoose.model('users',userSchema)

export default userModel
```

Let's break it down:

*   `mongoose.Schema({...})`:  This defines the structure of our user data. It's like saying, "Here are the rules for what a user looks like in our database."
*   `firstName : { type : String, required : [true, "Provide first name"] }`: This says the `firstName` property must be a string, and it's *required* (meaning a user can't be created without a first name). The part `[true, "Provide first name"]` means that if the `firstName` is missing, the error "Provide first name" will be displayed.
*   `unique: true` in email's object config makes sure we don't have multiple users registered with the same email.
*   `timeStamps: true` option lets the database automatically create `createdAt` and `updatedAt` fields, which tells us when a user was created and last updated.

This schema defines how the user looks in the database. When we use `userModel.create(userData)` to create a new user, Mongoose uses this schema to validate that the data conforms to what the database expects!

You can see the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter includes a snippet of API code that uses this model.

**Conclusion:**

In this chapter, we learned about the User Data Model. We saw how it acts as a blueprint for user data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and we looked at the internal implementation of the User Data Model in our application.

Next, we'll explore [API Route Handlers](03_api_route_handlers.md) which handles the http requests.

---
# Chapter 3: API Route Handlers

Welcome back! In [Chapter 2: User Data Model](02_user_data_model.md), we learned how to structure and store user data. Now, how do we *access* and *manipulate* that data? That's where **API Route Handlers** come in!

Imagine you're using the LinkedIn app and you click the "Like" button on a post. What happens behind the scenes? Your click sends a request to the server, and an API Route Handler is responsible for handling that request, updating the database (to register your "like"), and sending a response back to your app (so the "Like" button changes color).

API Route Handlers are like waiters in a restaurant. They take orders (requests), process them (interact with the database), and return responses (meals). Each handler is responsible for a specific "endpoint," like `/api/login` or `/api/like`.

**Why do we need API Route Handlers?**

Without API Route Handlers, our app would be static and unable to interact with any data. We wouldn't be able to log in, register, post updates, or connect with friends. They provide a structured way for the front-end (what you see) to communicate with the back-end (where the data is stored).

Specifically, API Route Handlers:

1.  **Receive Requests:** They listen for incoming HTTP requests (like GET, POST, PUT, DELETE).
2.  **Process Requests:** They perform actions based on the request, such as reading data from the database, updating data, or creating new data.
3.  **Send Responses:** They send back a response to the client (your browser or app), usually in the form of JSON data.

**Key Concepts:**

Let's break down the key concepts of API Route Handlers:

*   **Endpoints:** A specific URL that an API Route Handler listens to (e.g., `/api/login`, `/api/register`, `/api/post`). Each endpoint corresponds to a specific action or resource.
*   **HTTP Methods:** The type of request being made. The most common ones are:

    *   `GET`: Used to retrieve data (e.g., getting a user's profile information).
    *   `POST`: Used to create new data (e.g., creating a new post).
    *   `PUT`: Used to update existing data (e.g., updating a user's profile information).
    *   `DELETE`: Used to delete data (e.g., deleting a post).
*   **Request:** The data sent from the client to the server. This can include information like user credentials (email, password), post content, or other parameters.
*   **Response:** The data sent back from the server to the client. This usually includes a status code (e.g., 200 for success, 400 for bad request, 500 for server error) and the actual data being requested (e.g., user profile information, a list of posts).
*   **Middleware:** As mentioned in [Chapter 1: User Authentication and Authorization](01_user_authentication_and_authorization.md), this is code that runs before the route handler. We use it to check authentication, authorization, or other common tasks.

**How do we use API Route Handlers?**

Let's look at the "Like" button example again. When you click the "Like" button, your app sends a `POST` request to the `/api/post/like` endpoint, along with the ID of the post you want to like.

Here's what a simplified version of the request might look like:

```json
{
  "_id": "654321abcdef0123456789" // The ID of the post being liked
}
```

The `/api/post/like` handler then:

1.  Finds the post in the database using the provided ID.
2.  Adds your user ID to the post's "like" array (or removes it if you're unliking).
3.  Sends back a response confirming the action was successful, and the updated "like" count.

Here's a simplified version of the response:

```json
{
  "message": "Liked",
  "data": ["userId1", "userId2", "yourUserId"], // An array of user IDs who have liked the post
  "success": true
}
```

This response tells your app that the "Like" was successfully registered, and provides the updated list of users who have liked the post.

**Internal Implementation:**

Let's see what happens under the hood when the `/api/post/like` endpoint is called:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/like)
    participant Database

    User->>Client-side App: Clicks "Like" button
    Client-side App->>API Route (/api/post/like): Sends POST request with post ID
    API Route (/api/post/like)->>Database: Finds post by ID and updates "like" array
    Database-->>API Route (/api/post/like): Returns updated post data
    API Route (/api/post/like)-->>Client-side App: Sends response with success and updated like count
    Client-side App->>User: Updates UI to reflect the "Like"
```

1.  **User Interaction:** The user clicks the "Like" button in the Client-side App.
2.  **API Request:** The Client-side App sends a `POST` request to the `/api/post/like` route, including the post ID in the request body.
3.  **Database Update:** The `/api/post/like` route (`src\app\api\post\like\route.js`) finds the post in the database, and either adds or removes the user's ID from the "like" array.
4.  **Response:** The API Route sends a response back to the Client-side App, indicating success and the updated list of likes.
5.  **UI Update:** The Client-side App updates the user interface to reflect the new "Like" status.

Here's a simplified version of the code for the `/api/post/like` route:

```javascript
import connectDB from '@/database/db' // Connect to the database
import postModel from '@/models/postModel' // Import the post data model
import { NextResponse } from 'next/server' // For sending responses

connectDB() // Connect to the database

export async function POST(request){
    try {
        // Get the post ID from the request
        const { _id } = await request.json()

        // Find the post in the database
        const post = await postModel.findOne({ _id : _id })

        // ... (Logic to add/remove the user's like)

        return NextResponse.json({
            message : 'Liked',
            data : post.like, // List of user IDs who have liked the post
            success : true
        })

    } catch (error) {
        return NextResponse.json({
            message  : error.message || error,
            error : true
        })
    }
}
```

Let's break it down:

*   `connectDB()`: Connects to the database, using the connection logic you will learn in the [Database Connection](07_database_connection.md) chapter.
*   `postModel`: This refers to the [Post Data Model](04_post_data_model.md) (which we'll cover later) and lets us interact with the "posts" collection in the database.
*   `request.json()`:  Extracts the JSON data from the incoming request.
*   `NextResponse.json()`: Creates a JSON response to send back to the client. This includes a `message`, the `data`, and a `success` flag. The most common response is in `JSON` format, which are easily readable and consumable.

Notice how this route handler uses the `postModel` (your later chapter) to interact with the database and retrieve the post information. The `postModel` defines the structure of a "post" just like the `userModel` in [Chapter 2: User Data Model](02_user_data_model.md) defines the structure of a user.

**Conclusion:**

In this chapter, we learned about API Route Handlers. We saw how they act as intermediaries between the front-end and back-end, handling requests, processing data, and sending responses. We explored the key concepts of endpoints, HTTP methods, requests, and responses.

In the next chapter, we'll delve into the [Post Data Model](04_post_data_model.md), which defines the structure of post data in our application.

---
# Chapter 4: Post Data Model

Welcome back! In [Chapter 3: API Route Handlers](03_api_route_handlers.md), we learned how to handle requests to create, update, and delete data. But what *is* that data we're working with when it comes to posts? That's where the **Post Data Model** comes in!

Imagine you're scrolling through your LinkedIn feed. Every post you see has some text, maybe an image, the user who posted it, and some likes and comments. The Post Data Model is like a template that defines what information each post contains and how it's organized.

Think of it like this: if the User Data Model (which you learned about in [Chapter 2: User Data Model](02_user_data_model.md)) is a blueprint for how to store user information, the Post Data Model is a blueprint for how to store post information!

**Why do we need a Post Data Model?**

Just like we needed a User Data Model to keep user data organized, we need a Post Data Model to keep post data organized. Without it, our application wouldn't know what to expect from each post, and it would be difficult to display and manage posts correctly.

Specifically, the Post Data Model ensures:

1.  **Consistency:** Every post has the same basic set of information.
2.  **Completeness:** We have all the information we need to represent a post.
3.  **Structure:** We know exactly where to find each piece of information for every post.

**Key Concepts:**

Let's break down what makes up our Post Data Model. It defines the properties (or attributes) of a post.

*   **Properties:** These are the individual pieces of information we store about each post. Examples include:

    *   `description`: The text content of the post (e.g., "Excited to share this article!").
    *   `image`: A link to an image in the post (if any).
    *   `userId`: The ID of the user who created the post. This links the post back to the user.
    *   `like`: An array containing the IDs of users who liked the post.
    *   `comment`: An array of comments related to the post.
*   **Data Types:** Each property has a specific data type, which tells us what kind of information it can hold.

    *   `String`: Text (e.g., description, image URLs).
    *   `Array`: A list of things (e.g., a list of user IDs who liked the post, a list of comments).
    *   `ObjectId`: A special type of ID used to link data between different parts of our database (e.g., linking a post to a user).

**How do we use the Post Data Model?**

Let's say we want to create a new post in our application. We'd use the Post Data Model as a template. We'd provide the necessary information (description, image URL, user ID), and our application would create a new post object based on the model.

Here's a simplified example (conceptually):

```javascript
const newPost = {
  description: "Check out my new project!",
  image: "https://example.com/image.jpg",
  userId: "654321abcdef0123456789" // The ID of the user who created the post
};
```

This `newPost` object now has the structure defined by our Post Data Model.

**Internal Implementation:**

Let's take a peek under the hood! When a user creates a new post, here's what happens:

```mermaid
sequenceDiagram
    participant User
    participant Client-side App
    participant API Route (/api/post/create)
    participant Post Data Model
    participant Database

    User->>Client-side App: Creates a new post
    Client-side App->>API Route (/api/post/create): Sends post data (description, image, userId)
    API Route (/api/post/create)->>Post Data Model: Creates a new post object based on model
    Post Data Model->>Database: Saves the new post object
    Database-->>API Route (/api/post/create): Returns success or error
    API Route (/api/post/create)-->>Client-side App: Returns success or error
    Client-side App->>User: Displays the new post
```

1.  **User Input:** The user creates a new post in the Client-side App.
2.  **API Request:** The Client-side App sends the post data to the `/api/post/create` route.
3.  **Model Creation:** The `/api/post/create` route uses the Post Data Model as a blueprint to create a new post object.
4.  **Database Save:** The new post object is saved to the database.

Now, let's look at the actual code in `src\models\postModel.js`:

```javascript
import mongoose from 'mongoose'

const postSchema = new mongoose.Schema({
    description : {
        type : String,
        default : ""
    },
    userId : {
        type : mongoose.Schema.Types.ObjectId,
        required : true,
        ref : 'users'
    },
    like : {
         type : Array,
         default : []
    }
},{
    timestamps : true
})

const postModel = mongoose.models.posts || mongoose.model("posts",postSchema)

export default postModel
```

Let's break it down:

*   `mongoose.Schema({...})`: This defines the structure of our post data.
*   `description : { type : String, default : "" }`: This says the `description` property must be a string, and if no description is provided, it defaults to an empty string.
*   `userId : { type : mongoose.Schema.Types.ObjectId, required : true, ref : 'users' }`: This says the `userId` property must be a special `ObjectId` that links to a user in the `users` collection.  `required : true` means a post can't be created without a user ID. `ref : 'users'` means this ID refers to a document in the `users` collection.
*   `timestamps: true`: This option lets the database automatically create `createdAt` and `updatedAt` fields.

```javascript
    like : {
         type : Array,
         default : []
    }
```

This snippet creates an Array which contains the list of users who "liked" the post.

The code from [API Route Handlers](03_api_route_handlers.md) which likes a post uses this model!

**Conclusion:**

In this chapter, we learned about the Post Data Model. We saw how it acts as a blueprint for post data, ensuring consistency, completeness, and structure. We explored the key concepts of properties and data types, and how they're used to represent a post in our application.

Next, we'll explore the [Context Provider (ContextData)](05_context_provider__contextdata_.md), which helps us share data across different parts of our application.

---
# Chapter 5: Context Provider (ContextData)

Welcome back! In [Chapter 4: Post Data Model](04_post_data_model.md), we learned how to structure post data in our LinkedIn clone. But what if we want to show the currently logged-in user's name and profile picture in multiple places on the page, like the header and the post upload section? We *could* pass the user data as props to each component, but that can get messy and repetitive! That's where the **Context Provider (ContextData)** comes to the rescue!

Think of ContextData like a central bulletin board where you can pin important information that many different components need to access. In our case, that information is the currently logged-in user. Any component that needs the user's information can simply "read" it from the ContextData, without having to receive it directly as a prop from its parent.

**Why do we need a Context Provider?**

Imagine you're building a house. You could run individual electrical wires from the power source to each light fixture, but that's inefficient. Instead, you use a central electrical panel to distribute power to all the rooms. Context Provider is like that electrical panel  it provides a central place to manage and share data across your application.

Specifically, Context Provider helps us:

1.  **Avoid Prop Drilling:** We don't have to pass data through multiple layers of components that don't actually need it.
2.  **Centralize Data:** We have one place to manage the data, making it easier to update and maintain.
3.  **Improve Code Readability:** Components can directly access the data they need, making the code easier to understand.

**Key Concepts:**

Let's break down the key concepts of Context Provider:

*   **Context:** Think of this as the "bulletin board" itself. It holds the data we want to share.
*   **Provider:** This is the component that "pins" the data to the context. It makes the data available to all its child components.
*   **Consumer (or `useContext` hook):** This is how components "read" the data from the context. They subscribe to the context and get notified whenever the data changes.

**How do we use the Context Provider?**

Let's say we want to display the currently logged-in user's name in the header. We'd do the following:

1.  **Create a Context:** We create a `ContextData` object using `createContext`. This is our bulletin board.
2.  **Create a Provider:**  We wrap our entire application (or a large part of it) with the `ContextData.Provider`. This is like putting the bulletin board up in a central location.
3.  **Provide the User Data:** Inside the `Provider`, we set the `value` prop to the user data. This is like pinning the user's name and profile picture to the bulletin board.
4.  **Consume the Data:** In the header component, we use the `useContext` hook to access the user data from the `ContextData`. This is like a component walking up to the bulletin board and reading the user's name.

Here's a simplified example of how to use Context Provider (using snippets from `src\providers\provider.js` and `src\components\Header.js`):

First, in `src\providers\provider.js`, we create our Context and Provider:

```javascript
import { createContext, useState, useEffect } from "react";

export const ContextData = createContext(null);

export const Provider = ({ children }) => {
    const [user, setData] = useState(null); // store user in state

    //...fetch user details
    return (
        <ContextData.Provider value={{ user }}>
            {children}
        </ContextData.Provider>
    );
};
```

Explanation:

* We import `createContext` and `useState` from React.
* We create a context called `ContextData`. It's initially `null` before we provide data to it.
* We create a `Provider` component that wraps our app. This is what makes the data available.
* We use `useState` to store the `user` data. This will be the current user.
* MOST IMPORTANTLY: We pass the `user` state variable as the `value` prop to `ContextData.Provider`. This "pins" the user data to the context, making it accessible to all child components wrapped by provider. `children` prop represent children components which will share the state.

Now, in `src\components\Header.js`, we use the `useContext` hook to access the user data:

```javascript
import { useContext } from "react";
import { ContextData } from "@/providers/provider";

const Header = () => {
    const { user } = useContext(ContextData);

    return (
        <header>
            {user ? <p>Welcome, {user.firstName}!</p> : <p>Please log in</p>}
        </header>
    );
};
```

Explanation:

*   We import `useContext` and our `ContextData`.
*   We call `useContext(ContextData)` to get the value that was provided by the `ContextData.Provider`. In our case, it's the `user` object.
*   Now we can access the user's `firstName` directly! If a user has logged in and has name "Alice", it will display "Welcome, Alice!".

That's it!  The `Header` component now has access to the current user's information without having to receive it as a prop. You can do this in other components as well!

**Internal Implementation:**

Let's see what happens under the hood when a component uses the `useContext` hook:

```mermaid
sequenceDiagram
    participant Component
    participant ContextData
    participant Provider

    Component->>ContextData: useContext(ContextData)
    ContextData->>Provider: Requests current value
    Provider-->>ContextData: Returns user data
    ContextData-->>Component: Returns user data
    Component->>Component: Renders with user data
```

1.  **Component calls useContext:** The component calls `useContext(ContextData)` to access the data.
2.  **ContextData requests from Provider:** The `useContext` hook internally asks the `Provider` for the current value of the context.
3.  **Provider returns data:** The `Provider` returns the user data that it's currently holding in its state.
4.  **Component receives data:** The `useContext` hook returns the user data to the component.
5.  **Component renders:** The component re-renders with the new user data.

Looking at the actual code (again from `src\providers\provider.js`), here's what's happening behind the scenes:

```javascript
export const Provider = ({ children }) => {
    const [user, setData] = useState(null);

    const fetchCurrentUserDetails = async() =>{
        const response = await axios.get("api/current-user")
        setData(response.data.data)
    }

    useEffect(()=>{
        fetchCurrentUserDetails()
    },[])

    return (
        <ContextData.Provider value={{ user, fetchCurrentUserDetails }}>
            { children }
        </ContextData.Provider>
    );
};
```

Explanation:

*   The `Provider` component fetches the current user's details.
*   The `fetchCurrentUserDetails` API call uses API Route Handler you learned in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   The `value` prop of `ContextData.Provider` is an object containing the `user` data, as well as the `fetchCurrentUserDetails` function which components can use to update the user details globally.

The files `src\app\(root)\page.js` ,`src\app\(root)\find-friends\page.js`, `src\app\(root)\[id]\page.js` and `src\components\PostDisplay.js` all use `useContext` hook to read user and `fetchCurrentUserDetails` states, so they can access user name, profile and update information.

**Conclusion:**

In this chapter, we learned about Context Provider (ContextData). We saw how it helps us share data across different components without prop drilling, centralizing data management, and improving code readability. We explored the key concepts of context, provider, and consumer, and saw how they work together.

In the next chapter, we'll learn about the [Avatar Component](06_avatar_component.md), which displays user profile pictures.

---
# Chapter 6: Avatar Component

Welcome back! In [Chapter 5: Context Provider (ContextData)](05_context_provider__contextdata_.md), we learned how to share user data across different components. Now, let's say we want to display user profile pictures in various places, like the header, post sections, and friend lists. We want a consistent look and feel everywhere, and we want to make it easy to navigate to the user's profile when you click the picture. This is where the **Avatar Component** comes in handy!

Think of the Avatar Component as a standardized frame for displaying user profile photos. It takes the user's profile picture URL and renders it within a consistent, circular frame. It also handles navigation to the user's profile page when you click on it. It's like having a reusable photo frame that you can put anywhere in your app!

**Why do we need an Avatar Component?**

Without an Avatar Component, we'd have to write the same code to display a profile picture every time we needed it. We'd have to handle image loading, styling (making it circular, setting the size), and navigation separately each time. This would lead to:

1.  **Repetitive Code:** We'd be writing the same code over and over again.
2.  **Inconsistent Look and Feel:** Different profile pictures might have slightly different styles.
3.  **Maintenance Nightmare:** If we wanted to change the style of all profile pictures, we'd have to update the code in multiple places.

The Avatar component helps us solve the issues.

**Key Concepts:**

Let's break down the key concepts of the Avatar Component:

*   **Reusability:** The Avatar Component is a reusable piece of UI that can be used in multiple places throughout the application.
*   **Consistency:** It ensures that all profile pictures have a consistent look and feel.
*   **Navigation:** It handles navigation to the user's profile page when clicked.

**How do we use the Avatar Component?**

Let's say we want to display a user's profile picture in the header of our application. We'd use the Avatar Component like this (referencing `src\components\Header.js`):

```javascript
<Avatar
    userId={user?._id}
    imageURL={user?.profile_pic}
    width={28}
    height={28}
    disable={true}
/>
```

Explanation:

*   `userId`: The ID of the user whose profile picture we want to display.
*   `imageURL`: The URL of the user's profile picture.
*   `width`: The width of the avatar in pixels.
*   `height`: The height of the avatar in pixels.
*   `disable`: If `true`, the avatar won't be clickable (no navigation).

When this code runs, the Avatar Component will:

1.  Load the image from the `imageURL`.
2.  Display the image in a circular frame with the specified `width` and `height`.
3.  Make the avatar clickable, navigating to the user's profile page when clicked (unless `disable` is set to `true`).

If `imageURL` is missing, it will display a default user icon.

**Internal Implementation:**

Let's see what happens under the hood when the Avatar Component is rendered:

```mermaid
sequenceDiagram
    participant Component
    participant Avatar Component
    participant Image (or Default Icon)
    participant Link

    Component->>Avatar Component: Renders Avatar Component with imageURL and userId
    Avatar Component->>Image (or Default Icon): Checks if imageURL exists
    alt imageURL exists
        Avatar Component->>Image: Renders Image component with imageURL
    else imageURL doesn't exist
        Avatar Component->>Image: Renders Default Icon
    end
    Avatar Component->>Link: Renders Link component with href to user profile
    Link->>Component: Returns rendered Avatar with clickable link
```

1.  **Component Renders Avatar:** A component renders the Avatar Component, passing in the `imageURL` and `userId`.
2.  **Avatar Checks for Image:** The Avatar Component checks if the `imageURL` exists.
3.  **Render Image or Icon:**
    *   If the `imageURL` exists, it renders an `Image` component with the provided URL.
    *   If the `imageURL` is missing, it renders a default user icon.
4.  **Wrap in Link:**  The Avatar Component wraps the image (or icon) in a `Link` component, which makes it clickable and navigates to the user's profile page (e.g., `/user/123`).
5.  **Returns Rendered Avatar:** The Avatar Component returns the rendered avatar with the clickable link.

Now, let's look at the actual code in `src\components\Avatar.js`:

```javascript
import React from 'react'
import Image from 'next/image'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { UserCircle2 } from 'lucide-react'

const Avatar = ({ imageURL, userId, width, height, disable , extraWidth = 0, extraHeight = 0 }) => {
    const path = usePathname()
    return (
        <Link
            href={disable ? path :  "/"+userId}
        >
            {
                imageURL ? (
                    <Image
                        src={imageURL}
                        width={width + extraWidth}
                        height={height + extraHeight}
                        alt='current user'
                        className='rounded-full overflow-hidden drop-shadow-sm'
                    />
                ) :
                    (
                        <UserCircle2 className='font-light text-gray-700' width={width + extraWidth}
                        height={height + extraHeight}/>
                    )
            }
        </Link>
    )
}

export default Avatar
```

Let's break it down:

*   `imageURL`, `userId`, `width`, and `height` are props passed to the component.
*   The component uses conditional rendering (`imageURL ? ... : ...`) to display either the image or a default icon, which keeps the UI consistent.
*   If `imageURL` is exist, it uses Next.js's `Image` component to display the profile picture. `className='rounded-full'` makes the image circular.
*   `Link` is the next.js component to enable routing by wrapping the Image component.
*   `<Link href={"/"+userId}>` creates a link to the user's profile page. When `disable` is false, the link goes to that user's profile page; otherwise, it does nothing.
*   `usePathname` is a Next.js hook to get the current URL.

The [Context Provider (ContextData)](05_context_provider__contextdata_.md) chapter gives several examples of the Avatar component used to display user profile images.

**Conclusion:**

In this chapter, we learned about the Avatar Component. We saw how it helps us display user profile pictures consistently and easily throughout our application. We explored the key concepts of reusability, consistency, and navigation, and we looked at the internal implementation of the Avatar Component.

In the next chapter, we'll delve into the [Database Connection](07_database_connection.md), which handles connection and querying to DB.

---
# Chapter 7: Database Connection

Welcome back! In [Chapter 6: Avatar Component](06_avatar_component.md), we learned how to display user profile pictures throughout our application. But all that user data, post data, and other information needs to be stored *somewhere*. That's where our **Database Connection** comes in!

Imagine your LinkedIn data  your profile, your posts, your connections  living inside a massive filing cabinet (the database). The Database Connection is like the special key that allows our application to open that filing cabinet and reliably read and write information to it. Without this key, our app can't access or modify the data!

**Why do we need a Database Connection?**

Think about what happens when you log into LinkedIn. The app needs to fetch your profile data from the database to display it. Or when you create a new post, the app needs to save that new post to the database. The Database Connection makes all of this possible.

Specifically, the Database Connection:

1.  **Establishes a connection:** It opens a line of communication between our application and the database.
2.  **Handles authentication:** It ensures that our application has the correct credentials (like a username and password) to access the database.
3.  **Manages the connection:** It keeps the connection alive and handles any errors that might occur.
4.  **Allows data transfer:** It enables us to send data to the database (like creating a new user) and retrieve data from the database (like fetching a user's profile).

**Key Concepts:**

Let's break down the key concepts of Database Connection:

*   **Connection String:** This is like the address and password for our database. It tells our application where to find the database and how to log in. It often contains information like the database server's address, the database name, a username, and a password. It's usually stored as an environment variable for security reasons.
*   **Database Client (Mongoose):**  This is a special tool that helps our application talk to the database. In our case, we are using Mongoose, which is a popular library for interacting with MongoDB databases. It provides a simpler and more structured way to perform database operations.
*   **Connection Pooling:** This is a technique that allows us to reuse existing database connections instead of creating a new connection every time we need to access the database. This can significantly improve the performance of our application.

**How do we use the Database Connection?**

In our application, we use the Database Connection to perform various database operations, such as:

*   **Creating a new user:** When a user registers for an account, we use the Database Connection to save their information to the database. You can see this in the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter.
*   **Fetching a user's profile:** When a user logs in, we use the Database Connection to retrieve their profile data from the database.
*   **Creating a new post:** When a user creates a new post, we use the Database Connection to save the post to the database.  Refer back to the [API Route Handlers](03_api_route_handlers.md) chapter and how it saves new Post data.

The main goal is to make sure that whenever we need to talk to our data storage, we can establish a connection successfully and safely.

**Internal Implementation:**

Let's take a peek under the hood! When our application starts up, it needs to establish a connection to the database.

Here's what happens step-by-step:

```mermaid
sequenceDiagram
    participant App
    participant Database Connection
    participant Mongoose
    participant MongoDB Database

    App->>Database Connection: Calls connectDB()
    Database Connection->>Mongoose: mongoose.connect(connectionString)
    Mongoose->>MongoDB Database: Establishes connection
    alt Connection Successful
        MongoDB Database-->>Mongoose: Connection confirmation
        Mongoose-->>Database Connection:  Connection confirmation
        Database Connection-->>App: Connection established
    else Connection Failed
        MongoDB Database-->>Mongoose: Error
        Mongoose-->>Database Connection: Error
        Database Connection-->>App: Error message
    end

```

1.  **App Calls connectDB():** Our application calls the `connectDB()` function to initiate the database connection.
2.  **Mongoose Connects:** The `connectDB()` function uses Mongoose to connect to the MongoDB database using the connection string.
3.  **Connection Attempt:** Mongoose attempts to establish a connection to the database using the provided connection string.
4.  **Success or Failure:**
    *   **Success:** If the connection is successful, Mongoose sends a confirmation message.
    *   **Failure:** If the connection fails (e.g., due to an invalid connection string or network issues), Mongoose sends an error message.
5.  **App Receives Confirmation or Error:** The `connectDB()` function receives either a confirmation message or an error message from Mongoose and handles it accordingly (e.g., logging a success message or displaying an error message).

Now, let's look at the actual code in `src\database\db.js`:

```javascript
import mongoose from "mongoose";

async function connectDb(){
    try {
        await mongoose.connect(process.env.MONGO_URI)
        const dbConnection = mongoose.connection
        dbConnection.on('db connected',()=>{
            console.log("connect to mongoDB")
        })
        dbConnection.on('error',(error)=>{
            console.log("connection failed "+error)
        })
    } catch (error) {
        console.log("Error in Database",error)
    }
}

export default connectDb
```

Let's break it down:

*   `import mongoose from "mongoose";`: This line imports the Mongoose library, which we'll use to interact with the MongoDB database.
*   `mongoose.connect(process.env.MONGO_URI)`: This is the key line that establishes the connection to the database. It uses the `mongoose.connect()` function, which takes the connection string as an argument.  `process.env.MONGO_URI` is an environment variable that stores the connection string.  Environment variables are a secure way to store sensitive information like database passwords.
*   `dbConnection.on('db connected',()=>{ console.log("connect to mongoDB") })`: This line sets up an event listener that will log a message to the console when the database connection is successfully established.
*   `dbConnection.on('error',(error)=>{ console.log("connection failed "+error) })`: This line sets up an event listener that will log an error message to the console if the database connection fails.
*   The code is wrapped in a `try...catch` block to handle any errors that might occur during the connection process.

Important Note: The `connectDb()` function *must* be called before performing any database operations.  You can see it being used in `/api/login` in the [User Authentication and Authorization](01_user_authentication_and_authorization.md) chapter and `/api/post/like` in [API Route Handlers](03_api_route_handlers.md).

**Conclusion:**

In this chapter, we learned about the Database Connection. We saw how it acts as the key to our database, allowing our application to reliably read and write data. We explored the key concepts of connection strings, database clients, and connection pooling, and we looked at the internal implementation of the Database Connection in our application.

In the next chapter, we'll delve into [Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md), which helps add and remove friends using this Database Connection.

---
# Chapter 8: Handle Add Remove Friends Helper

Welcome back! In [Chapter 7: Database Connection](07_database_connection.md), we learned how our application connects to the database. Now, let's imagine a common scenario: you're browsing LinkedIn and want to connect with a new contact. You click "Add Friend," and *poof*, you're connected! How does our application handle adding and removing friends without repeating the same code everywhere? That's where the **Handle Add Remove Friends Helper** comes to the rescue!

Think of this helper function as a dedicated tool in your toolbox, specifically designed for managing friendships.  Instead of writing out the instructions for adding or removing a friend *every single time* you need to, you just grab this tool and use it.

**Why do we need a Helper Function for Adding/Removing Friends?**

Imagine you have "Add Friend" buttons on different parts of your LinkedIn clone: on user profiles, in search results, and maybe even in a "suggested friends" list. Without a helper, you'd need to copy and paste the same code for each of those buttons. This would be:

1.  **Repetitive:**  Writing the same code over and over is tedious!
2.  **Error-prone:**  Copying and pasting can lead to mistakes.
3.  **Hard to Maintain:**  If you need to change *how* adding a friend works (e.g., add a confirmation message), you'd have to update it in *every* single place!

The "Handle Add Remove Friends Helper" solves all of these problems by centralizing the logic.

**Key Concepts:**

Let's break down what this helper does:

*   **Encapsulation:** The helper *encapsulates* (wraps up) all the logic for adding or removing a friend into a single, reusable function.
*   **API Request:**  It makes a request to our API (the backend part of our application) to actually perform the add/remove operation in the database. You can see how the API works in [Chapter 3: API Route Handlers](03_api_route_handlers.md).
*   **Reusability:**  You can call this helper from *any* component in your application.

**How do we use the Handle Add Remove Friends Helper?**

Let's say you're on a user's profile page and you want to add them as a friend. Here's how you'd use the helper (referencing `src\app\(root)\[id]\page.js`):

```javascript
const handleAddFriend = async(friendId)=>{
  const response = await handleAddRemoveFriends(friendId);
  fetchUserDetails();
}
```

Explanation:

1.  `handleAddFriend` function is called (for example, when you click an "Add Friend" button).
2.  `friendId` is the ID of the user you want to add/remove.
3.  `await handleAddRemoveFriends(friendId)` calls the helper function, passing in the `friendId`. This triggers the API request to add/remove friend.
4.  `fetchUserDetails()`: After the friend is added/removed, it calls a function to update the user details on the page.

The helper function then returns a response containing the status of the operation, after doing some magic in the background.

**Internal Implementation:**

Let's see what happens under the hood when you call the Handle Add Remove Friends Helper.

```mermaid
sequenceDiagram
    participant User Interface
    participant Handle Add Remove Friends Helper
    participant API Route (/api/add-remove-friends)
    participant Database

    User Interface->>Handle Add Remove Friends Helper: handleAddRemoveFriends(friendId)
    Handle Add Remove Friends Helper->>API Route (/api/add-remove-friends): Sends POST request with friendId
    API Route (/api/add-remove-friends)->>Database: Updates user's friend list (add/remove)
    Database-->>API Route (/api/add-remove-friends): Returns success/error
    API Route (/api/add-remove-friends)-->>Handle Add Remove Friends Helper: Returns success/error message
    Handle Add Remove Friends Helper->>User Interface: Returns success/error message
```

1.  **User Clicks Button:** The user clicks an "Add Friend" or "Remove Friend" button in the User Interface.
2.  **Helper is Called:** The `handleAddRemoveFriends` helper function is called, passing in the `friendId`.
3.  **API Request:**  The helper sends a `POST` request to the `/api/add-remove-friends` API route, including the `friendId` in the request body.
4.  **Database Update:** The API route handles the logic to either add the `friendId` to the current user's friend list or remove it if it's already there.  This involves updating the database, which you learned about in [Chapter 7: Database Connection](07_database_connection.md) and [Chapter 2: User Data Model](02_user_data_model.md).
5.  **Response:** The API route sends a response back to the helper, indicating success or failure.
6.  **Message to User:** The helper might display a message to the user (e.g., "Friend added!" or "Friend removed!").

Now, let's look at the actual code in `src\helpers\handleAddRemoveFriends.js`:

```javascript
import axios from 'axios'

const handleAddRemoveFriends = async(friendId) =>{
    const payload = {
        friendId : friendId
    }
    const response = await axios.post('/api/add-remove-friends',payload)

    return response.data
}

export default handleAddRemoveFriends
```

Let's break it down:

*   `import axios from 'axios'`: This line imports the `axios` library, which we use to make HTTP requests to our API.
*   `const payload = { friendId : friendId }`: This creates an object called `payload` containing the `friendId`. This is the data we're sending to the API.
*   `const response = await axios.post('/api/add-remove-friends',payload)`: This line makes a `POST` request to the `/api/add-remove-friends` API route, sending the `payload` (the friend ID) along with the request.
*   `return response.data`:  This line returns the data that the API sends back, which will contain a success/error message.

Important Note:  The helper function *doesn't* directly modify the database. It sends a request to an API route, which *then* interacts with the database. This separation of concerns makes our code more organized and easier to maintain.

**Conclusion:**

In this chapter, we learned about the Handle Add Remove Friends Helper. We saw how it encapsulates the logic for adding and removing friends, making our code more reusable, less error-prone, and easier to maintain. We explored the key concepts of encapsulation, API requests, and reusability, and we looked at the internal implementation of the helper function.

In the next chapter, we'll explore [Image Upload Helper](09_image_upload_helper.md), which helps us upload and manage images in our application.


Relevant Code Snippets (Code itself remains unchanged):
--- File: src\app\api\register\route.js ---
import userModel from '@/models/userModel'
import  { NextResponse } from 'next/server'
import bcryptjs from 'bcryptjs'
import uploadImage from '@/helpers/uploadImage'
import connectDB from '@/database/db'

connectDB()

export async function POST(request){
    try {
        const formData = await request.formData()
        const firstName = formData.get('firstName')
        const lastName = formData.get('lastName')
        const location = formData.get('location')
        const occupation = formData.get('occupation')
        const email  = formData.get('email')
        const password = formData.get('password')
        const profilePic = formData.get('profile_pic')

        //checking email id
        const checkEmailid = await userModel.findOne({ email })
        if(checkEmailid){
            return NextResponse.json({ message  : "Already exits user"})
        }

        //password into hash format
        const salt = await bcryptjs.genSalt(10)
        const hashPassword = await bcryptjs.hash(password , salt)

        //upload profile pic in cloudinary
        let uploadProfilePic = ''
        if(profilePic?.name){
            uploadProfilePic = await uploadImage(profilePic)
        } 
        
        const payload = {
            firstName,
            lastName,
            location,
            occupation,
            email,
            password : hashPassword,
            profile_pic : uploadProfilePic.url,
            profileViews : Math.floor(Math.random() * 1000),  
            profileImpressions : Math.floor(Math.random() * 1000),
        }

        const user  = new userModel(payload)
        const saveUserData = await user.save()

        return NextResponse.json({message : "User created successfully", data : saveUserData, success : true })

    } catch (error) {
        return NextResponse.json({ message : error.message || error })
    }
}

--- File: src\app\api\upload-post\route.js ---
import connectDB from '@/database/db'
import { NextResponse } from 'next/server'
import postModel from '@/models/postModel'
import { getUserDetailsFromToken } from '@/helpers/getUserDetailsFromToken'
import uploadImage from '@/helpers/uploadImage'


connectDB()
export async function POST(request){
    try {
        const user = await getUserDetailsFromToken(request)

        if(!user){
            return NextResponse.json({
                message : "Please login",
                error : true
            })
        }

        const formdata = await request.formData()
        const description = formdata.get("description")
        const image = formdata.get("image")

        let postUpload = ''
        if(image){
            postUpload = await uploadImage(image)
        } 

        const payload =  {
            image : postUpload.url,
            description : description,
            userId : user._id
        }

        const post = new postModel(payload)
        const savePost = await post.save()

        return NextResponse.json({
            message : "Upload successfully",
            success : true,
            data : savePost
        })

    } catch (error) {
        return NextResponse.json({ message : error.message || message })
    }   
}

--- File: src\helpers\uploadImage.js ---
import {v2 as cloudinary} from 'cloudinary';
          
cloudinary.config({ 
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME, 
  api_key: process.env.CLOUDINARY_API_KEY, 
  api_secret: process.env.CLOUDINARY_API_SECRET
});


const uploadImage = async(file)=>{
    const buffer = Buffer.from(await file.arrayBuffer())

    const uploadFileData = await new Promise((resolve,reject)=>{
        cloudinary.uploader.upload_stream({ folder : 'linkedIn_clone'},(error,uploadResult)=>{
            return resolve(uploadResult)
        }).end(buffer)
    })

    return uploadFileData
}

export default uploadImage

Instructions for the chapter (Generate content in English unless specified otherwise):
- Start with a clear heading (e.g., `# Chapter 9: Image Upload Helper`). Use the provided concept name.

- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.

- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.

- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.

- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).

- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.

- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .

- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.

- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.

- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .

- Heavily use analogies and examples throughout to help beginners understand.

- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).

- Ensure the tone is welcoming and easy for a newcomer to understand.

- Output *only* the Markdown content for this chapter.

Now, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):

2025-05-30 19:09:12,939 - INFO - RESPONSE (from cache): # Chapter 9: Image Upload Helper

Welcome back! In [Chapter 8: Handle Add Remove Friends Helper](08_handle_add_remove_friends_helper.md), we learned how to easily manage friendships in our LinkedIn clone. Now, let's talk about adding images to your profile or posts. Imagine you want to upload a profile picture. You select the image, click upload, and *bam*, it's there! But how does our application handle uploading that image to a safe and reliable storage location? That's where the **Image Upload Helper** comes in!

Think of the Image Upload Helper as a specialized assistant whose only job is to take images from our application and safely store them in the cloud. Instead of writing the same complex image uploading code *every time* we need to handle an image, we just use this assistant.

**Why do we need an Image Upload Helper?**

Imagine you have multiple places in your LinkedIn clone where users can upload images: profile pictures, post images, company logos, etc. Without a helper, you'd need to write the same image uploading code in each of those places. This would be:

1.  **Repetitive:** Writing the same code over and over is, well, boring!
2.  **Complex:** Image uploading can be tricky, involving things like handling file sizes, different image formats, and security.
3.  **Dependent on Cloudinary:** We are using `Cloudinary` to store images. We don't want to repeat Cloudinary setup everywhere.

The Image Upload Helper solves all of these problems by centralizing the uploading logic and the Cloudinary setup.

**Key Concepts:**

Let's break down what this helper does:

*   **Cloudinary:** This is a cloud-based service that provides image and video storage, optimization, and delivery. We're using it to store our uploaded images. Think of it as a super-organized online photo album.
*   **Encapsulation:** The helper *encapsulates* all the complex image uploading logic and Cloudinary setup into a single, reusable function.
*   **Reusability:** You can call this helper from *any* component or API route in your application.

**How do we use the Image Upload Helper?**

Let's say you're updating your profile picture. Here's how you'd use the helper (referencing `src\app\api\register\route.js`):

```javascript
if(profilePic?.name){
    uploadProfilePic = await uploadImage(profilePic)
}
```

Explanation:

1.  `profilePic` contains the image file selected by the user. The `?.name` is a way to safely check if the image exists.
2.  `await uploadImage(profilePic)` calls the helper function, passing in the image file.
3.  `uploadProfilePic` will then contain the Cloudinary url for our new profile picture.

The helper function then returns an object containing the URL of the uploaded image, after doing some magic in the background.

**Internal Implementation:**

Let's see what happens under the hood when you call the Image Upload Helper.

```mermaid
sequenceDiagram
    participant Your App
    participant Image Upload Helper
    participant Cloudinary

    Your App->>Image Upload Helper: uploadImage(imageFile)
    Image Upload Helper->>Cloudinary: Uploads image to Cloudinary
    Cloudinary-->>Image Upload Helper: Returns image URL
    Image Upload Helper-->>Your App: Returns image URL
```

1.  **You Call the Helper:** Your code calls the `uploadImage()` helper function, passing in the image file.
2.  **Upload to Cloudinary:** The helper sends the image to Cloudinary.
3.  **Cloudinary Responds:** Cloudinary stores the image and generates a unique URL for it.
4.  **Helper Returns URL:** The helper function returns the URL of the uploaded image to your code.

Now, let's look at the actual code in `src\helpers\uploadImage.js`:

```javascript
import {v2 as cloudinary} from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

const uploadImage = async(file)=>{
    const buffer = Buffer.from(await file.arrayBuffer())

    const uploadFileData = await new Promise((resolve,reject)=>{
        cloudinary.uploader.upload_stream({ folder : 'linkedIn_clone'},(error,uploadResult)=>{
            return resolve(uploadResult)
        }).end(buffer)
    })

    return uploadFileData
}

export default uploadImage
```

Let's break it down:

*   `import {v2 as cloudinary} from 'cloudinary';`: This line imports the Cloudinary library, which we'll use to interact with the Cloudinary service.
*   `cloudinary.config({...})`: This configures Cloudinary with our account credentials (cloud name, API key, and API secret). *Important:* These credentials should be stored as environment variables for security!
*   `const uploadImage = async(file) =>{...}`: defines the `uploadImage` helper function. It takes the `file` parameter as an argument.

*   `const buffer = Buffer.from(await file.arrayBuffer())`: Converts the file to a `Buffer`, which Cloudinary needs.
*   `cloudinary.uploader.upload_stream({...})`: Uploads the image to Cloudinary using a special "upload stream". The `{ folder : 'linkedIn_clone'}` part tells Cloudinary to store the images in a folder named "linkedIn_clone".
*   `return uploadFileData`:  Returns the data that Cloudinary sends back, which includes the URL of the uploaded image.

Remember how [Chapter 7: Database Connection](07_database_connection.md) emphasized the importance of the connection string? Similarily, it's paramount to store your Cloudinary credentials as environment variables.

**Examples of Use**

You can see the `uploadImage` function being used in:

*   `src\app\api\register\route.js`: To upload profile pictures during user registration. The `uploadProfilePic = await uploadImage(profilePic)` call will return the URL of the image. This URL is then saved to the `profile_pic` field in the [User Data Model](02_user_data_model.md).
*   `src\app\api\upload-post\route.js`: To upload images when creating a new post. The `postUpload = await uploadImage(image)` call returns the URL, which is then saved to the `image` field in the [Post Data Model](04_post_data_model.md).

**Conclusion:**

In this chapter, we learned about the Image Upload Helper. We saw how it encapsulates the complex logic of uploading images to Cloudinary, making our code more reusable and easier to maintain. We explored the key concepts of Cloudinary, encapsulation, and reusability, and we looked at the internal implementation of the helper function.

You now have a robust way to manage image uploads in your LinkedIn clone!

There are no further chapters defined. You've reached the end of the tutorial!

